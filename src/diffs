diff -r ../src/ARCHIMEDE/Archimede_VolumeSection.cxx ../../../GEOM_SRC/src/ARCHIMEDE/Archimede_VolumeSection.cxx
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/ARCHIMEDE/Archimede_VolumeSection.hxx ../../../GEOM_SRC/src/ARCHIMEDE/Archimede_VolumeSection.hxx
27c27
< //  $Header$
---
> //  $Header$
Only in ../../../GEOM_SRC/src/ARCHIMEDE: CVS
diff -r ../src/ARCHIMEDE/Makefile.in ../../../GEOM_SRC/src/ARCHIMEDE/Makefile.in
27c27
< #  $Header$
---
> #  $Header$
30c30
< top_builddir=../../..
---
> top_builddir=../..
39c39
< LIB = libGeometryArchimede.la 
---
> LIB = libGEOMArchimede.la 
47,49c47,49
< CPPFLAGS += $(OCC_INCLUDES) $(QT_INCLUDES)
< CXXFLAGS += $(OCC_CXXFLAGS)
< LDFLAGS  += $(CAS_LDPATH) -lTKGeomBase
---
> CPPFLAGS += $(OCC_INCLUDES) $(QT_INCLUDES) -I${KERNEL_ROOT_DIR}/include/salome
> CXXFLAGS += $(OCC_CXXFLAGS) -I${KERNEL_ROOT_DIR}/include/salome
> LDFLAGS  += $(OCC_KERNEL_LIBS) $(OCC_MODELER_LIBS) -L${KERNEL_ROOT_DIR}/lib/salome
Only in ../../../GEOM_SRC/src/: CVS
Only in ../src/: diffs
Only in ../../../GEOM_SRC/src/GEOM: CVS
diff -r ../src/GEOM/geom.cxx ../../../GEOM_SRC/src/GEOM/geom.cxx
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOM/GEOM_Gen_i.cc ../../../GEOM_SRC/src/GEOM/GEOM_Gen_i.cc
27c27
< //  $Header$
---
> //  $Header$
45a46
> #include <gp_Elips.hxx>
57,59d57
< #if OCC_VERSION_MAJOR >= 5
< #include <BRepAlgo.hxx>
< #else
61d58
< #endif
156,163d152
< Standard_EXPORT static Standard_Boolean IsValid(const TopoDS_Shape& S) {
< #if OCC_VERSION_MAJOR >= 5
<   return BRepAlgo::IsValid(S);
< #else
<   return BRepAlgoAPI::IsValid(S);
< #endif
< }
< 
775,781c764,765
<   GEOM::GEOM_Shape_var shapeIOR;
<   if(strcmp(stringIOR,"") != 0){
<     CORBA::Object_var anObject = _orb->string_to_object(stringIOR);
<     if(!CORBA::is_nil(anObject))
<       shapeIOR =  GEOM::GEOM_Shape::_narrow(anObject.in()) ;
<   }
<   return shapeIOR._retn() ;
---
>   GEOM::GEOM_Shape_var shapeIOR =  GEOM::GEOM_Shape::_narrow(_orb->string_to_object(stringIOR)) ;
>   return shapeIOR ;
1465c1449
<   if( tds.IsNull() || !IsValid(tds) )
---
>   if( tds.IsNull() || !BRepAlgoAPI::IsValid(tds) )
1571c1555
<   if( outW.IsNull() || !IsValid(outW) )
---
>   if( outW.IsNull() || !BRepAlgoAPI::IsValid(outW) )
1631c1615
<   if( !IsValid(aShape) )
---
>   if( !BRepAlgoAPI::IsValid(aShape) )
1644c1628
<   if( !IsValid(aFace) )
---
>   if( !BRepAlgoAPI::IsValid(aFace) )
1655c1639
<   if( !IsValid(aWire) )
---
>   if( !BRepAlgoAPI::IsValid(aWire) )
1660c1644
<   if( outerW.IsNull() || !IsValid(outerW) ) 
---
>   if( outerW.IsNull() || !BRepAlgoAPI::IsValid(outerW) ) 
1674c1658
<     if( !GetShapeFromIndex( aShape, TopAbs_FACE, ListIdEndFace[0], aTemp ) || tmp.IsNull() || !IsValid(aTemp) )
---
>     if( !GetShapeFromIndex( aShape, TopAbs_FACE, ListIdEndFace[0], aTemp ) || tmp.IsNull() || !BRepAlgoAPI::IsValid(aTemp) )
1684c1668
<       if( !W.IsNull() && IsValid(W) )
---
>       if( !W.IsNull() && BRepAlgoAPI::IsValid(W) )
1835c1819
<     if( !IsValid(F) ) {
---
>     if( !BRepAlgoAPI::IsValid(F) ) {
1866c1850
<   if( outerW.IsNull() || !IsValid(outerW) ) {
---
>   if( outerW.IsNull() || !BRepAlgoAPI::IsValid(outerW) ) {
2373c2357
<   if( !IsValid(shape) ) {
---
>   if( !BRepAlgoAPI::IsValid(shape) ) {
2427c2411
<   if( !IsValid(shape) ) {
---
>   if( !BRepAlgoAPI::IsValid(shape) ) {
2568,2569d2551
< 
< 
2598,2599d2579
< 
< 
2883c2863
<     if( !IsValid(tds) ) {
---
>     if( !BRepAlgoAPI::IsValid(tds) ) {
3027c3007
<   if( !IsValid(tds) ) {
---
>   if( !BRepAlgoAPI::IsValid(tds) ) {
3319c3299
<     if( !IsValid(tds) ) {
---
>     if( !BRepAlgoAPI::IsValid(tds) ) {
3358c3338
<     if( !IsValid(tds) ) {
---
>     if( !BRepAlgoAPI::IsValid(tds) ) {
3731a3712,3746
> // function : MakeEllipse()
> // purpose  : 
> //================================================================================
> GEOM::GEOM_Shape_ptr GEOM_Gen_i::MakeEllipse( const GEOM::PointStruct& pstruct,
> 					      const GEOM::DirStruct& dstruct,
> 					      CORBA::Double radius_major,
> 					      CORBA::Double radius_minor )
>   throw (SALOME::SALOME_Exception) 
> {
>   GEOM::GEOM_Shape_var result;
>   TopoDS_Shape tds ;
>   
>   try {
>     gp_Pnt p(pstruct.x, pstruct.y, pstruct.z) ;
>     gp_Dir d(dstruct.PS.x, dstruct.PS.y, dstruct.PS.z) ;
> 
>     const gp_Ax2 axis(p, d) ;
>     gp_Elips anEllipse( axis, radius_major, radius_minor ) ;
>     BRepBuilderAPI_MakeEdge MakeEdge( anEllipse );
>     tds = MakeEdge.Edge();
> 
>   }
>   catch(Standard_Failure) {
>     THROW_SALOME_CORBA_EXCEPTION("Exception catched in GEOM_Gen_i::MakeEllipse", SALOME::BAD_PARAM);
>   }
>   if (tds.IsNull()) {
>     THROW_SALOME_CORBA_EXCEPTION("Make Ellipse aborted", SALOME::BAD_PARAM);
>   } 
>   result = CreateObject(tds);
>   const char *entry = InsertInLabel(tds, result->Name(), myCurrentOCAFDoc) ;
>   result->ShapeId(entry);
>   return result ;  
> }
> 
> //================================================================================
4377c4392
<   if (  !IsValid(tds) ) {
---
>   if (  !BRepAlgoAPI::IsValid(tds) ) {
4911,4915c4926,4930
<   PortableServer::ObjectId * GeometryEngine_factory(CORBA::ORB_ptr orb,
< 						    PortableServer::POA_ptr poa, 
< 						    PortableServer::ObjectId * contId,
< 						    const char *instanceName, 
< 						    const char * interfaceName)
---
>   PortableServer::ObjectId * GEOMEngine_factory(CORBA::ORB_ptr orb,
> 						PortableServer::POA_ptr poa, 
> 						PortableServer::ObjectId * contId,
> 						const char *instanceName, 
> 						const char * interfaceName)
4917d4931
< MESSAGE("mygeom")
4919d4932
< MESSAGE("mygeom")
4921d4933
< MESSAGE("mygeom")
diff -r ../src/GEOM/GEOM_Gen_i.hh ../../../GEOM_SRC/src/GEOM/GEOM_Gen_i.hh
27c27
< //  $Header$ 
---
> //  $Header$ 
569a570,574
>   GEOM::GEOM_Shape_ptr MakeEllipse(const GEOM::PointStruct& pstruct,
> 				   const GEOM::DirStruct& dstruct,
> 				   CORBA::Double radius_major,
> 				   CORBA::Double radiusminus )
>     throw (SALOME::SALOME_Exception) ;
diff -r ../src/GEOM/GEOM_Shape_i.cc ../../../GEOM_SRC/src/GEOM/GEOM_Shape_i.cc
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOM/GEOM_Shape_i.hh ../../../GEOM_SRC/src/GEOM/GEOM_Shape_i.hh
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOM/Makefile.in ../../../GEOM_SRC/src/GEOM/Makefile.in
27c27
< #  $Header$
---
> #  $Header$
30c30
< top_builddir=../../..
---
> top_builddir=../..
39c39
< LIB = libGeometryEngine.la
---
> LIB = libGEOMEngine.la
41c41
< LIB_SERVER_IDL = SALOME_Component.idl SALOMEDS.idl SALOME_Exception.idl GEOM_Gen.idl GEOM_Shape.idl 
---
> LIB_SERVER_IDL = SALOME_Component.idl SALOMEDS.idl SALOME_Exception.idl GEOM_Gen.idl GEOM_Shape.idl
52,54c52,54
< CPPFLAGS += $(OCC_INCLUDES)
< CXXFLAGS += $(OCC_CXXFLAGS)
< LDFLAGS  +=  -lGeometryDS -lTOOLSDS -lSalomeNS -lSalomeContainer -lGeometryPartition -lGeometryArchimede $(CAS_LDPATH) -lTKIGES -lTKSTEP -lTKFillet -lTKOffset 
---
> CPPFLAGS += $(OCC_INCLUDES) -I${KERNEL_ROOT_DIR}/include/salome
> CXXFLAGS += $(OCC_CXXFLAGS) -I${KERNEL_ROOT_DIR}/include/salome
> LDFLAGS  += $(OCC_KERNEL_LIBS) $(OCC_MODELER_LIBS) $(OCC_DATAEXCHANGE_LIBS) -lGEOMDS -lSalomeDS -lSalomeNS -lSalomeContainer -lGEOMPartition -lGEOMArchimede -L${KERNEL_ROOT_DIR}/lib/salome
Only in ../../../GEOM_SRC/src/GEOMClient: CVS
diff -r ../src/GEOMClient/GEOM_Client.cxx ../../../GEOM_SRC/src/GEOMClient/GEOM_Client.cxx
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMClient/GEOM_Client.hxx ../../../GEOM_SRC/src/GEOMClient/GEOM_Client.hxx
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMClient/Makefile.in ../../../GEOM_SRC/src/GEOMClient/Makefile.in
27c27
< #  $Header$
---
> #  $Header$
30c30
< top_builddir=../../..
---
> top_builddir=../..
43c43
< LIB = libGeometryClient.la
---
> LIB = libGEOMClient.la
54,56c54,56
< CPPFLAGS += $(OCC_INCLUDES)
< CXXFLAGS += $(OCC_CXXFLAGS)
< LDFLAGS  += $(CAS_LDPATH) -lTKTopAlgo   
---
> CPPFLAGS += $(OCC_INCLUDES) -I${KERNEL_ROOT_DIR}/include/salome
> CXXFLAGS += $(OCC_CXXFLAGS) -I${KERNEL_ROOT_DIR}/include/salome
> LDFLAGS  += $(OCC_KERNEL_LIBS) $(OCC_MODELER_LIBS) -L${KERNEL_ROOT_DIR}/lib/salome
Only in ../../../GEOM_SRC/src/GEOMDS: CVS
diff -r ../src/GEOMDS/GEOMDS_Application.cxx ../../../GEOM_SRC/src/GEOMDS/GEOMDS_Application.cxx
27c27
< //  $Header$
---
> //  $Header$
60c60
<   return Standard_CString ("Resources");
---
>   return Standard_CString ("GEOMDS_Resources");
diff -r ../src/GEOMDS/GEOMDS_Commands.cxx ../../../GEOM_SRC/src/GEOMDS/GEOMDS_Commands.cxx
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMDS/GEOMDS_Commands.hxx ../../../GEOM_SRC/src/GEOMDS/GEOMDS_Commands.hxx
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMDS/GEOMDS_Explorer.cxx ../../../GEOM_SRC/src/GEOMDS/GEOMDS_Explorer.cxx
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMDS/Makefile.in ../../../GEOM_SRC/src/GEOMDS/Makefile.in
27c27
< #  $Header$
---
> #  $Header$
30c30
< top_builddir=../../..
---
> top_builddir=../..
39c39
< LIB = libGeometryDS.la 
---
> LIB = libGEOMDS.la 
64,66c64,66
< CPPFLAGS += $(OCC_INCLUDES)
< CXXFLAGS += $(OCC_CXXFLAGS)
< LDFLAGS  += $(CAS_LDPATH) -lTKCAF
---
> CPPFLAGS += $(OCC_INCLUDES) -I${KERNEL_ROOT_DIR}/include/salome
> CXXFLAGS += $(OCC_CXXFLAGS) -I${KERNEL_ROOT_DIR}/include/salome
> LDFLAGS  += $(OCC_KERNEL_LIBS)  $(OCC_OCAF_LIBS)
Only in ../../../GEOM_SRC/src/GEOMFiltersSelection: CVS
diff -r ../src/GEOMFiltersSelection/GEOM_EdgeFilter.cxx ../../../GEOM_SRC/src/GEOMFiltersSelection/GEOM_EdgeFilter.cxx
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMFiltersSelection/GEOM_FaceFilter.cxx ../../../GEOM_SRC/src/GEOMFiltersSelection/GEOM_FaceFilter.cxx
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMFiltersSelection/GEOM_ShapeTypeFilter.cxx ../../../GEOM_SRC/src/GEOMFiltersSelection/GEOM_ShapeTypeFilter.cxx
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMFiltersSelection/Makefile.in ../../../GEOM_SRC/src/GEOMFiltersSelection/Makefile.in
27c27
< #  $Header$
---
> #  $Header$
30c30
< top_builddir=../../..
---
> top_builddir=../..
39c39
< LIB = libGeometryFiltersSelection.la 
---
> LIB = libGEOMFiltersSelection.la 
55,57c55,57
< CPPFLAGS += $(OCC_INCLUDES) $(QT_INCLUDES) $(PYTHON_INCLUDES) $(VTK_INCLUDES)
< CXXFLAGS += $(OCC_CXXFLAGS)
< LDFLAGS  +=  -lSalomeGUI
---
> CPPFLAGS += $(OCC_INCLUDES) $(QT_INCLUDES) $(PYTHON_INCLUDES) $(VTK_INCLUDES) -I${KERNEL_ROOT_DIR}/include/salome
> CXXFLAGS += $(OCC_CXXFLAGS) -I${KERNEL_ROOT_DIR}/include/salome
> LDFLAGS  += $(OCC_KERNEL_LIBS) -L${KERNEL_ROOT_DIR}/lib/salome
Only in ../../../GEOM_SRC/src/GEOMGUI: CVS
diff -r ../src/GEOMGUI/GeometryGUI_aParameterDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_aParameterDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_aParameterDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_aParameterDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_ArcDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_ArcDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
61,62c61,62
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_ARC")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_ARC")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
211c211
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_ArcDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_ArcDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_ArchimedeDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_ArchimedeDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
64,65c64,65
<   QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_ARCHIMEDE")));
<   QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>   QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_ARCHIMEDE")));
>   QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
247c247
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_ArchimedeDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_ArchimedeDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_BndBoxDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_BndBoxDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
63,64c63,64
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_BOUNDING_BOX")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_BOUNDING_BOX")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
256c256
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_BndBoxDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_BndBoxDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_BoxDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_BoxDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
68,70c68,70
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_BOX_2P")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
<     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_BOX_DXYZ")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_BOX_2P")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
>     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_BOX_DXYZ")));
265c265
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_BoxDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_BoxDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_CenterMassDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_CenterMassDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
59,60c59,60
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_CENTERMASS")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_CENTERMASS")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
246c246
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_ChamferDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_ChamferDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
79,82c79,82
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_CHAMFER_ALL")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
<     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_CHAMFER_EDGE")));
<     QPixmap image3(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_CHAMFER_FACE")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_CHAMFER_ALL")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
>     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_CHAMFER_EDGE")));
>     QPixmap image3(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_CHAMFER_FACE")));
411c411
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_ChamferDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_ChamferDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_CheckShape.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_CheckShape.cxx
27c27
< //  $Header$
---
> //  $Header$
66,67c66,67
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_CHECKSHAPE")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_CHECKSHAPE")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
192c192
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_CheckShape.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_CheckShape.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_CircleDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_CircleDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
64,65c64,65
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_CIRCLE_PV")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_CIRCLE_PV")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
213c213
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_CircleDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_CircleDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_CommonDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_CommonDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
62,63c62,63
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_COMMON")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_COMMON")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
200c200
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_CommonDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_CommonDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_CompoundDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_CompoundDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
60,61c60,61
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_BUILD_COMPOUND")));
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_BUILD_COMPOUND")));
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
183c183
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_CompoundDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_CompoundDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_ConeDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_ConeDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
64,66c64,66
<   QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_CONE_PV")));
<   QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
<   QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_CONE_DXYZ")));
---
>   QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_CONE_PV")));
>   QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
>   QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_CONE_DXYZ")));
307c307
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_ConeDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_ConeDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_CutDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_CutDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
63,64c63,64
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_CUT")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_CUT")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
201c201
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_CutDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_CutDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI.cxx
27c27
< //  $Header$
---
> //  $Header$
181a182
> #include "GeometryGUI_EllipseDlg.h"       // Method ELLIPSE
361c362
<     Engines::Component_var comp = desktop->getEngine("FactoryServer", "Geometry");
---
>     Engines::Component_var comp = desktop->getEngine("FactoryServer", "GEOM");
719c720
<   GEOM::GEOM_Shape_var aShape ;
---
>   GEOM::GEOM_Shape_ptr aShape ;
721c722
<   
---
> 
729,734c730,735
<       if (obj->FindAttribute(anAttr, "AttributeIOR")) {
< 	anIOR = SALOMEDS::AttributeIOR::_narrow(anAttr);
< 	aShape = myComponentGeom->GetIORFromString(anIOR->Value()) ;
< 	if(!CORBA::is_nil(aShape)) testResult = true ;
< 	return aShape._retn();
<       }
---
>        if (obj->FindAttribute(anAttr, "AttributeIOR")) {
>          anIOR = SALOMEDS::AttributeIOR::_narrow(anAttr);
> 	 aShape = myComponentGeom->GetIORFromString(anIOR->Value()) ;
> 	 testResult = true ;
> 	 return aShape;
>        }
740a742
>     testResult = true ;
742,745c744,746
<     if(!CORBA::is_nil(aShape)) testResult = true ;
<     return aShape._retn();
<   }
<   return aShape._retn();
---
>     return aShape;
>   } 
>   return aShape ;
1785a1787,1815
> //=====================================================================================
> // function : MakeEllipseAndDisplay()
> // purpose  :
> //=====================================================================================
> void GeometryGUI::MakeEllipseAndDisplay( const gp_Pnt CenterPoint,
> 					 const gp_Dir dir,
> 					 const Standard_Real Major_Radius,
> 					 const Standard_Real Minor_Radius )
> {
>   try {
>     GEOM::PointStruct pstruct = myComponentGeom->MakePointStruct( CenterPoint.X(), CenterPoint.Y(),  CenterPoint.Z() ) ;
>     GEOM::PointStruct d = myComponentGeom->MakePointStruct( dir.X(), dir.Y(), dir.Z() ) ;
>     GEOM::DirStruct dstruct = myComponentGeom->MakeDirection(d) ;
>     
>     GEOM::GEOM_Shape_var result = myComponentGeom->MakeEllipse(pstruct, dstruct, Major_Radius, Minor_Radius) ;
>     if ( result->_is_nil() ) {
>       myDesktop->putInfo(tr("GEOM_PRP_ABORT") );
>       return ;
>     }
>     result->NameType(tr("GEOM_ELLIPSE"));
>     if ( Display( result ) )
>       myDesktop->putInfo(tr("GEOM_PRP_DONE"));
>   }
>   catch (const SALOME::SALOME_Exception& S_ex) {
>     QtCatchCorbaException(S_ex);
>   }
>   return  ;
> }
> 
3298a3329,3336
>     case 3014:  // ELLIPSE
>       {
> 	GeomGUI->EmitSignalDeactivateDialog() ;
> 	SALOME_Selection* Sel = SALOME_Selection::Selection( GeomGUI->myActiveStudy->getSelection() );
>   	GeometryGUI_EllipseDlg *aDlg = new GeometryGUI_EllipseDlg( parent, "", Sel ) ;
> 	break ;
>       }
> 
4219c4257
< 		  Engines::Component_var comp = GeomGUI->myDesktop->getEngine("FactoryServer","Geometry");
---
> 		  Engines::Component_var comp = GeomGUI->myDesktop->getEngine("FactoryServer","GEOM");
5014c5052,5053
<       aName->SetValue( tr("GEOM_MEN_COMPONENT") );
---
>       //      aName->SetValue( tr("GEOM_MEN_COMPONENT") );
>       aName->SetValue( QAD_Application::getDesktop()->getComponentUserName( "GEOM" ) );
5218c5257,5258
<     aName->SetValue( tr("GEOM_MEN_COMPONENT") );
---
>     //    aName->SetValue( tr("GEOM_MEN_COMPONENT") );
>     aName->SetValue( QAD_Application::getDesktop()->getComponentUserName( "GEOM" ) );
5332c5372,5373
<     aName->SetValue( tr("GEOM_MEN_COMPONENT") );
---
>     //    aName->SetValue( tr("GEOM_MEN_COMPONENT") );
>     aName->SetValue( QAD_Application::getDesktop()->getComponentUserName( "GEOM" ) );
diff -r ../src/GEOMGUI/GeometryGUI_CylinderDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_CylinderDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
63,65c63,65
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_CYLINDER_PV")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
<     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_CYLINDER_DXYZ")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_CYLINDER_PV")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
>     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_CYLINDER_DXYZ")));
286c286
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_CylinderDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_CylinderDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_DistanceDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_DistanceDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
74,75c74,75
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_MINDIST")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_MINDIST")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
224c224
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_DistanceDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_DistanceDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_EdgeDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_EdgeDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
62,63c62,63
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_BUILD_EDGE")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_BUILD_EDGE")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
201c201
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_EdgeDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_EdgeDlg.h
27c27
< //  $Header$
---
> //  $Header$
Only in ../../../GEOM_SRC/src/GEOMGUI: GeometryGUI_EllipseDlg.cxx
Only in ../../../GEOM_SRC/src/GEOMGUI: GeometryGUI_EllipseDlg.h
diff -r ../src/GEOMGUI/GeometryGUI_FaceDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_FaceDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
63,64c63,64
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_BUILD_FACE")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_BUILD_FACE")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
193c193
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_FaceDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_FaceDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_FilletDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_FilletDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
78,81c78,81
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_FILLET_ALL")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
<     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_FILLET_EDGE")));
<     QPixmap image3(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_FILLET_FACE")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_FILLET_ALL")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
>     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_FILLET_EDGE")));
>     QPixmap image3(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_FILLET_FACE")));
344c344
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_FilletDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_FilletDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_FillingDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_FillingDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
67,68c67,68
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_FILLING")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_FILLING")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
411c411
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_FillingDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_FillingDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_FillingHoleDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_FillingHoleDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
67,68c67,68
<   QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_SEWING")));
<   QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>   QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_SEWING")));
>   QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
210c210
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_FillingHoleDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_FillingHoleDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_FuseDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_FuseDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
63,64c63,64
<      QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_FUSE")));
<      QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>      QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_FUSE")));
>      QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
201c201
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_FuseDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_FuseDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI.h
27c27
< //  $Header$
---
> //  $Header$
168a169
>   void MakeEllipseAndDisplay( const gp_Pnt CenterPoint, const gp_Dir dir, const Standard_Real Major_Radius, const Standard_Real Minor_Radius) ;
Only in ../src/GEOMGUI: GeometryGUI_icons.po
diff -r ../src/GEOMGUI/GeometryGUI_InertiaDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_InertiaDlg.cxx
56,57c56,57
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_INERTIA")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_INERTIA")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
291c291
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_InertiaDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_InertiaDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_LineDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_LineDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
65,68c65,68
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_LINE_2P")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
<     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_LINE_PV")));
<     QPixmap image3(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_LINE_EDGE")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_LINE_2P")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
>     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_LINE_PV")));
>     QPixmap image3(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_LINE_EDGE")));
207c207
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_LineDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_LineDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_MaxToleranceDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_MaxToleranceDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
67,68c67,68
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_TOLERANCE")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_TOLERANCE")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
266c266
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_MaxToleranceDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_MaxToleranceDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_MirrorDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_MirrorDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
68,69c68,69
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_MIRROR")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_MIRROR")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
204c204
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_MirrorDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_MirrorDlg.h
27c27
< //  $Header$
---
> //  $Header$
Only in ../src/GEOMGUI: GeometryGUI_msg_en.po
Only in ../src/GEOMGUI: GeometryGUI_msg_fr.po
diff -r ../src/GEOMGUI/GeometryGUI_MultiRotationDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_MultiRotationDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
76,78c76,78
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_MULTIROTATION_SIMPLE")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
<     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_MULTIROTATION_DOUBLE")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_MULTIROTATION_SIMPLE")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
>     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_MULTIROTATION_DOUBLE")));
380c380
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_MultiRotationDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_MultiRotationDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_MultiTranslationDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_MultiTranslationDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
72,74c72,74
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_MULTITRANSLATION_SIMPLE")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
<     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_MULTITRANSLATION_DOUBLE")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_MULTITRANSLATION_SIMPLE")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
>     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_MULTITRANSLATION_DOUBLE")));
417c417
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_MultiTranslationDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_MultiTranslationDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_OrientationDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_OrientationDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
69,70c69,70
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_ORIENTATION")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_ORIENTATION")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
218c218
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_OrientationDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_OrientationDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_PartitionDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_PartitionDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
59,60c59,60
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_PARTITION")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_PARTITION")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
248c248
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_PartitionDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_PartitionDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_PipeDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_PipeDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
53,55d52
< #if OCC_VERSION_MAJOR >= 5
< #include <BRepAlgo.hxx>
< #else
57d53
< #endif
70,71c66,67
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_PIPE")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_PIPE")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
208c204
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
393,395d388
< #if OCC_VERSION_MAJOR >= 5
< 		if (  BRepAlgo::IsValid(tds) ) 
< #else
397d389
< #endif
diff -r ../src/GEOMGUI/GeometryGUI_PipeDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_PipeDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_PlaneDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_PlaneDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
73,76c73,76
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_PLANE_PV")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
<     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_PLANE_DXYZ")));
<     QPixmap image3(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_PLANE_FACE")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_PLANE_PV")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
>     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_PLANE_DXYZ")));
>     QPixmap image3(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_PLANE_FACE")));
379c379
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_PlaneDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_PlaneDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_PointDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_PointDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
43,45d42
< #if OCC_VERSION_MAJOR >= 5
< #include <BRepAlgo.hxx>
< #else
47d43
< #endif
84,86c80,82
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_POINT")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
<     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_POINT_EDGE")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_POINT")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
>     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_POINT_EDGE")));
285c281
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
770,772d765
< #if OCC_VERSION_MAJOR >= 5
<   if( anEdge.IsNull() || !BRepAlgo::IsValid(anEdge) )
< #else
774d766
< #endif
diff -r ../src/GEOMGUI/GeometryGUI_PointDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_PointDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_PrismDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_PrismDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
69,70c69,70
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_PRISM")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_PRISM")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
231c231
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_PrismDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_PrismDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_PropertiesDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_PropertiesDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
63,64c63,64
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_BASICPROPERTIES")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_BASICPROPERTIES")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
209c209
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_RevolDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_RevolDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
65,66c65,66
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_REVOL")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_REVOL")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
229c229
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_RevolDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_RevolDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_RotationDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_RotationDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
66,67c66,67
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_ROTATION")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_ROTATION")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
224c224
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_RotationDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_RotationDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_ScaleDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_ScaleDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
64,65c64,65
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_SCALE")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_SCALE")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
211c211
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_ScaleDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_ScaleDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_SectionDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_SectionDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
63,64c63,64
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_SECTION")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_SECTION")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
199c199
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_SewingDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_SewingDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
63,64c63,64
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_SEWING")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_SEWING")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
199c199
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_SewingDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_SewingDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_ShellDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_ShellDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
60,61c60,61
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_SHELL")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_SHELL")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
180c180
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_ShellDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_ShellDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_SphereDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_SphereDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
66,68c66,68
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_SPHERE_P")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
<     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_SPHERE_DXYZ")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_SPHERE_P")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
>     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_SPHERE_DXYZ")));
243c243
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_SphereDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_SphereDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_SpinBox.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_SpinBox.cxx
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_SpinBox.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_SpinBox.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_SubShapeDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_SubShapeDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
75,76c75,76
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_SUBSHAPE")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_SUBSHAPE")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
234c234
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_SubShapeDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_SubShapeDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_SuppressFacesDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_SuppressFacesDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
66,67c66,67
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_SUPRESS_FACE")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_SUPRESS_FACE")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
210c210
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_SuppressFacesDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_SuppressFacesDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_SuppressHoleDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_SuppressHoleDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
73,75c73,75
<   QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_SUPRESS_HOLE")));
<   QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
<   QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_SUPRESS_HOLE_FACE_SHELL")));
---
>   QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_SUPRESS_HOLE")));
>   QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
>   QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_SUPRESS_HOLE_FACE_SHELL")));
310c310
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_SuppressHoleDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_SuppressHoleDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_Swig.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_Swig.cxx
27c27
< //  $Header$
---
> //  $Header$
62c62
< GeometryGUI_Swig::GeometryGUI_Swig()
---
> GEOM_Swig::GEOM_Swig()
67c67
< GeometryGUI_Swig::~GeometryGUI_Swig()
---
> GEOM_Swig::~GEOM_Swig()
72c72
< void GeometryGUI_Swig::createAndDisplayGO(const char* Entry)
---
> void GEOM_Swig::createAndDisplayGO(const char* Entry)
79c79
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
156c156
< int  GeometryGUI_Swig::getIndexTopology(const char* SubIOR, const char* IOR)
---
> int  GEOM_Swig::getIndexTopology(const char* SubIOR, const char* IOR)
158c158
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
181c181
< const char* GeometryGUI_Swig::getShapeTypeString(const char* IOR)
---
> const char* GEOM_Swig::getShapeTypeString(const char* IOR)
183c183
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
248c248
< const char* GeometryGUI_Swig::getShapeTypeIcon(const char* IOR)
---
> const char* GEOM_Swig::getShapeTypeIcon(const char* IOR)
250c250
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
281c281
< void GeometryGUI_Swig::setDisplayMode(const char* Entry, int mode)
---
> void GEOM_Swig::setDisplayMode(const char* Entry, int mode)
301c301
< void GeometryGUI_Swig::setColor(const char* Entry, int red, int green, int blue)
---
> void GEOM_Swig::setColor(const char* Entry, int red, int green, int blue)
321c321
< void GeometryGUI_Swig::setTransparency(const char* Entry, float transp)
---
> void GEOM_Swig::setTransparency(const char* Entry, float transp)
diff -r ../src/GEOMGUI/GeometryGUI_Swig.hxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_Swig.hxx
27c27
< //  $Header$
---
> //  $Header$
39c39
< class GeometryGUI_Swig
---
> class GEOM_Swig
42,43c42,43
<   GeometryGUI_Swig();
<   ~GeometryGUI_Swig();
---
>   GEOM_Swig();
>   ~GEOM_Swig();
diff -r ../src/GEOMGUI/GeometryGUI_Swig.i ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_Swig.i
27c27
< //  $Header$
---
> //  $Header$
33c33
< class GeometryGUI_Swig
---
> class GEOM_Swig
36,37c36,37
<   GeometryGUI_Swig();
<   ~GeometryGUI_Swig();
---
>   GEOM_Swig();
>   ~GEOM_Swig();
diff -r ../src/GEOMGUI/GeometryGUI_TorusDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_TorusDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
67,69c67,69
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_TORUS_PV")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
<     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_TORUS_DXYZ")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_TORUS_PV")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
>     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_TORUS_DXYZ")));
287c287
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_TorusDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_TorusDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_TranslationDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_TranslationDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
65,66c65,66
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_TRANSLATION")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_TRANSLATION")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
241c241
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_TranslationDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_TranslationDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_TransparencyDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_TransparencyDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_VectorDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_VectorDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
69,71c69,71
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_VECTOR_2P")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
<     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_VECTOR_DXYZ")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_VECTOR_2P")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
>     QPixmap image2(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_VECTOR_DXYZ")));
269c269
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_VectorDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_VectorDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_WhatisDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_WhatisDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
71,72c71,72
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_WHATIS")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_WHATIS")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
190c190
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_WhatisDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_WhatisDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_WireDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_WireDlg.cxx
27c27
< //  $Header$
---
> //  $Header$
61,62c61,62
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_BUILD_WIRE")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_BUILD_WIRE")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
183c183
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
diff -r ../src/GEOMGUI/GeometryGUI_WireDlg.h ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_WireDlg.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/GEOMGUI/GeometryGUI_WorkingPlaneDlg.cxx ../../../GEOM_SRC/src/GEOMGUI/GeometryGUI_WorkingPlaneDlg.cxx
64,65c64,65
<     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_DLG_WPLANE_FACE")));
<     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GeometryGUI",tr("ICON_SELECT")));
---
>     QPixmap image0(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_DLG_WPLANE_FACE")));
>     QPixmap image1(QAD_Desktop::getResourceManager()->loadPixmap( "GEOM",tr("ICON_SELECT")));
186c186
<   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "Geometry");
---
>   Engines::Component_var comp = QAD_Application::getDesktop()->getEngine("FactoryServer", "GEOM");
Only in ../../../GEOM_SRC/src/GEOMGUI: GEOM_icons.po
Only in ../../../GEOM_SRC/src/GEOMGUI: GEOM_msg_en.po
Only in ../../../GEOM_SRC/src/GEOMGUI: GEOM_msg_fr.po
diff -r ../src/GEOMGUI/Makefile.in ../../../GEOM_SRC/src/GEOMGUI/Makefile.in
27c27
< #  $Header$
---
> #  $Header$
30c30
< top_builddir=../../..
---
> top_builddir=../..
43,45c43,45
< 	GeometryGUI_icons.po \
< 	GeometryGUI_msg_en.po \
< 	GeometryGUI_msg_fr.po
---
> 	GEOM_icons.po \
> 	GEOM_msg_en.po \
> 	GEOM_msg_fr.po
48c48
< LIB = libGeometryGUI.la
---
> LIB = libGEOMGUI.la
101a102
> 		GeometryGUI_EllipseDlg.cxx
155c156,157
<                 GeometryGUI_SuppressHoleDlg.h
---
>                 GeometryGUI_SuppressHoleDlg.h \
> 		GeometryGUI_EllipseDlg.h
169,170c171,172
< CPPFLAGS += $(QT_INCLUDES) $(VTK_INCLUDES) $(OGL_INCLUDES) $(OCC_INCLUDES) $(PYTHON_INCLUDES)
< CXXFLAGS += $(OCC_CXXFLAGS)
---
> CPPFLAGS += $(QT_INCLUDES) $(VTK_INCLUDES) $(OGL_INCLUDES) $(OCC_INCLUDES) $(PYTHON_INCLUDES) -I${KERNEL_ROOT_DIR}/include/salome
> CXXFLAGS += $(OCC_CXXFLAGS) -I${KERNEL_ROOT_DIR}/include/salome
172c174
< LDFLAGS += -lOCCViewer -lVTKViewer -lSalomeObject -lSalomeGUI -lGeometryClient -lGeometryObject -lGeometryFiltersSelection -lGeometrySketcher $(CAS_LDPATH) -lTKFillet -lTKOffset
---
> LDFLAGS += -lOCCViewer -lVTKViewer -lSalomeObject -lSalomeGUI -lGEOMClient -lGEOMObject -lGEOMFiltersSelection -lGEOMSketcher $(OCC_KERNEL_LIBS) $(OCC_MODELER_LIBS) -L${KERNEL_ROOT_DIR}/lib/salome
diff -r ../src/GEOM_SWIG/batchmode_geompy.py ../../../GEOM_SRC/src/GEOM_SWIG/batchmode_geompy.py
10c10
< #  $Header$
---
> #  $Header$
12a13
> import GEOM
14a16
> modulecatalog = naming_service.Resolve("/Kernel/ModulCatalog")
16c18
< geom = lcc.FindOrLoadComponent("FactoryServer", "Geometry")
---
> geom = lcc.FindOrLoadComponent("FactoryServer", "GEOM")
25c27,31
<         FName.SetValue("Geometry")
---
> #        FName.SetValue("Geometry")
> 
> 	Comp = modulecatalog.GetComponent( "GEOM" )
> 	FName.SetValue( Comp._get_componentusername() )
> 
Only in ../../../GEOM_SRC/src/GEOM_SWIG: CVS
diff -r ../src/GEOM_SWIG/GEOM_example2.py ../../../GEOM_SRC/src/GEOM_SWIG/GEOM_example2.py
27c27
< #  $Header$
---
> #  $Header$
33c33
< geom = salome.lcc.FindOrLoadComponent("FactoryServer", "Geometry")
---
> geom = salome.lcc.FindOrLoadComponent("FactoryServer", "GEOM")
diff -r ../src/GEOM_SWIG/GEOM_example3.py ../../../GEOM_SRC/src/GEOM_SWIG/GEOM_example3.py
27c27
< #  $Header$
---
> #  $Header$
34c34
< geom = salome.lcc.FindOrLoadComponent("FactoryServer", "Geometry")
---
> geom = salome.lcc.FindOrLoadComponent("FactoryServer", "GEOM")
37c37
< gg = salome.ImportComponentGUI("Geometry")
---
> gg = salome.ImportComponentGUI("GEOM")
112c112
< #gg.setColor(id_cage,255,255,0)
\ No newline at end of file
---
> #gg.setColor(id_cage,255,255,0)
diff -r ../src/GEOM_SWIG/GEOM_example4.py ../../../GEOM_SRC/src/GEOM_SWIG/GEOM_example4.py
36c36
< geom = salome.lcc.FindOrLoadComponent("FactoryServer", "Geometry")
---
> geom = salome.lcc.FindOrLoadComponent("FactoryServer", "GEOM")
diff -r ../src/GEOM_SWIG/GEOM_example.py ../../../GEOM_SRC/src/GEOM_SWIG/GEOM_example.py
27c27
< #  $Header$
---
> #  $Header$
diff -r ../src/GEOM_SWIG/GEOM_moteur.py ../../../GEOM_SRC/src/GEOM_SWIG/GEOM_moteur.py
27c27
< #  $Header$
---
> #  $Header$
33c33
< geom = salome.lcc.FindOrLoadComponent("FactoryServer", "Geometry")
---
> geom = salome.lcc.FindOrLoadComponent("FactoryServer", "GEOM")
diff -r ../src/GEOM_SWIG/geompy.py ../../../GEOM_SRC/src/GEOM_SWIG/geompy.py
27c27
< #  $Header$
---
> #  $Header$
35c35
< geom = salome.lcc.FindOrLoadComponent("FactoryServer", "Geometry")
---
> geom = salome.lcc.FindOrLoadComponent("FactoryServer", "GEOM")
39c39
< gg = salome.ImportComponentGUI("Geometry")
---
> gg = salome.ImportComponentGUI("GEOM")
46c46
<         FName.SetValue("Geometry")
---
>         FName.SetValue( salome.sg.getComponentUserName("GEOM") )
Only in ../../../GEOM_SRC/src/GEOM_SWIG: GEOM_shared_modules.py
Only in ../../../GEOM_SRC/src/GEOM_SWIG: GEOM_shared_modules.py~
diff -r ../src/GEOM_SWIG/GEOM_usinggeom.py ../../../GEOM_SRC/src/GEOM_SWIG/GEOM_usinggeom.py
27c27
< #  $Header$
---
> #  $Header$
33c33
< geom = salome.lcc.FindOrLoadComponent("FactoryServer", "Geometry")
---
> geom = salome.lcc.FindOrLoadComponent("FactoryServer", "GEOM")
Only in ../src/GEOM_SWIG: libGeometry_Swig.i
Only in ../../../GEOM_SRC/src/GEOM_SWIG: libGEOM_Swig.i
diff -r ../src/GEOM_SWIG/Makefile.in ../../../GEOM_SRC/src/GEOM_SWIG/Makefile.in
27c27
< #  $Header$
---
> #  $Header$
30c30
< top_builddir=../../..
---
> top_builddir=../..
39c39
< LIB = libGeometry_Swigcmodule.la
---
> LIB = libGEOM_Swigcmodule.la
42,43c42,43
< SWIG_DEF = libGeometry_Swig.i
< EXPORT_PYSCRIPTS = libGeometry_Swig.py geompy.py batchmode_geompy.py \
---
> SWIG_DEF = libGEOM_Swig.i
> EXPORT_PYSCRIPTS = libGEOM_Swig.py geompy.py batchmode_geompy.py \
62a63,65
> EXPORT_SHAREDPYSCRIPTS=\
> 		 GEOM_shared_modules.py
> 
65c68
< LDFLAGS+= -lGeometryGUI
---
> LDFLAGS+= -lGEOMGUI
diff -r ../src/Makefile.in ../../../GEOM_SRC/src/Makefile.in
25c25
< #  $Header$
---
> #  $Header$
28c28
< top_builddir=../..
---
> top_builddir=..
Only in ../../../GEOM_SRC/src/OBJECT: CVS
diff -r ../src/OBJECT/GEOM_Actor.cxx ../../../GEOM_SRC/src/OBJECT/GEOM_Actor.cxx
27c27
< //  $Header$
---
> //  $Header$
277,278c277
<  if(WireframeMapper!=NULL) this->EstimatedRenderTime = WireframeMapper->GetTimeToDraw(); 
<  else if(ShadingMapper!=NULL) this->EstimatedRenderTime = ShadingMapper->GetTimeToDraw();
---
>   this->EstimatedRenderTime = WireframeMapper->GetTimeToDraw();
diff -r ../src/OBJECT/GEOM_Actor.h ../../../GEOM_SRC/src/OBJECT/GEOM_Actor.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/OBJECT/GEOM_AISShape.cxx ../../../GEOM_SRC/src/OBJECT/GEOM_AISShape.cxx
27c27
< //  $Header$
---
> //  $Header$
104,112c104
<       
<       Graphic3d_MaterialAspect aMatAspect;
<       aMatAspect.SetAmbient( 1 );
<       aMatAspect.SetDiffuse( 0 );
<       aMatAspect.SetEmissive( 0 );
<       aMatAspect.SetShininess(1 );
<       aMatAspect.SetSpecular( 0 );
<       
<       myDrawer->ShadingAspect()->Aspect()->SetFrontMaterial(aMatAspect);
---
>       myDrawer->ShadingAspect()->Aspect()->SetFrontMaterial(Graphic3d_NOM_BRASS);
114c106
<       
---
> 
diff -r ../src/OBJECT/GEOM_AssemblyBuilder.cxx ../../../GEOM_SRC/src/OBJECT/GEOM_AssemblyBuilder.cxx
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/OBJECT/GEOM_AssemblyBuilder.h ../../../GEOM_SRC/src/OBJECT/GEOM_AssemblyBuilder.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/OBJECT/GEOM_InteractiveObject.cxx ../../../GEOM_SRC/src/OBJECT/GEOM_InteractiveObject.cxx
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/OBJECT/GEOM_OCCReader.cxx ../../../GEOM_SRC/src/OBJECT/GEOM_OCCReader.cxx
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/OBJECT/GEOM_OCCReader.h ../../../GEOM_SRC/src/OBJECT/GEOM_OCCReader.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/OBJECT/Makefile.in ../../../GEOM_SRC/src/OBJECT/Makefile.in
28c28
< top_builddir=../../..
---
> top_builddir=../..
45c45
< LIB = libGeometryObject.la
---
> LIB = libGEOMObject.la
58,59c58,60
< CPPFLAGS+=$(QT_INCLUDES) $(PYTHON_INCLUDES) $(OCC_INCLUDES) $(VTK_INCLUDES) $(OGL_INCLUDES)
< LDFLAGS+=$(QT_MT_LIBS) $(VTK_LIBS) $(OGL_LIBS) $(PYTHON_LIBS) -lSalomeObject
---
> CPPFLAGS+=$(QT_INCLUDES) $(PYTHON_INCLUDES) $(OCC_INCLUDES) $(VTK_INCLUDES) $(OGL_INCLUDES) -I${KERNEL_ROOT_DIR}/include/salome
> CXXFLAGS += -I${KERNEL_ROOT_DIR}/include/salome
> LDFLAGS+=$(QT_MT_LIBS) $(OCC_KERNEL_LIBS) $(OCC_VIEWER_LIBS) $(VTK_LIBS) $(OGL_LIBS) $(PYTHON_LIBS) -lSalomeObject -L${KERNEL_ROOT_DIR}/lib/salome
Only in ../../../GEOM_SRC/src/PARTITION: CVS
diff -r ../src/PARTITION/Makefile.in ../../../GEOM_SRC/src/PARTITION/Makefile.in
27c27
< #  $Header$
---
> #  $Header$
30c30
< top_builddir=../../..
---
> top_builddir=../..
38c38
< LIB = libGeometryPartition.la
---
> LIB = libGEOMPartition.la
56,58c56,58
< CPPFLAGS += $(OCC_INCLUDES)
< CXXFLAGS += $(OCC_CXXFLAGS)
< LDFLAGS += $(CAS_LDPATH) -lTKBool
---
> CPPFLAGS += $(OCC_INCLUDES) -I${KERNEL_ROOT_DIR}/include/salome
> CXXFLAGS += $(OCC_CXXFLAGS) -I${KERNEL_ROOT_DIR}/include/salome
> LDFLAGS += $(OCC_KERNEL_LIBS) $(OCC_MODELER_LIBS) -L${KERNEL_ROOT_DIR}/lib/salome
diff -r ../src/PARTITION/Partition_Inter2d.cdl ../../../GEOM_SRC/src/PARTITION/Partition_Inter2d.cdl
65,66c65
<                      AsDes : mutable AsDes from BRepAlgo;
<                      F: Face from TopoDS)
---
>                      AsDes : mutable AsDes from BRepAlgo)
72,88c71
<         --          is returned insead of V.
<         --          Optional F is a face  E1  and  E2  are on. If F is
<         --          provided, it is used  to  find  new vertices on E1
<         --          and E2 resulting from intersection of new edges on
<         --          the two  other  faces  the  F  interferes with and
<         --          through which E1 and  E2  pass  too. This helps to
<         --          avoid small edges.
< 
< 
<     GetTolerance(myclass; theV : Vertex from TopoDS;
<                           theU : Real from Standard;
<                           theE : Edge from TopoDS;
<                           theAsDes : AsDes from BRepAlgo)
<         returns Real from Standard;
<         ---Purpose: Returns  tolerance  theV   must   have  atfer  its
<         --          addition to theE with  theU parameter. theAsDes is
<         --          used to find pcurves of theE
---
>         --          is returned insead of V. 
diff -r ../src/PARTITION/Partition_Inter2d.cxx ../../../GEOM_SRC/src/PARTITION/Partition_Inter2d.cxx
4,20c4,20
< //  CEDRAT, EDF R& D, LEG, PRINCIPIA R& D, BUREAU VERITAS
< //
< //  This library is free software; you can redistribute it and/or
< //  modify it under the terms of the GNU Lesser General Public
< //  License as published by the Free Software Foundation; either
< //  version 2.1 of the License.
< //
< //  This library is distributed in the hope that it will be useful,
< //  but WITHOUT ANY WARRANTY; without even the implied warranty of
< //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
< //  Lesser General Public License for more details.
< //
< //  You should have received a copy of the GNU Lesser General Public
< //  License along with this library; if not, write to the Free Software
< //  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
< //
< //  See http://www.opencascade.org/SALOME/ or email : webmaster.salome@opencascade.org
---
> //  CEDRAT, EDF R&D, LEG, PRINCIPIA R&D, BUREAU VERITAS 
> // 
> //  This library is free software; you can redistribute it and/or 
> //  modify it under the terms of the GNU Lesser General Public 
> //  License as published by the Free Software Foundation; either 
> //  version 2.1 of the License. 
> // 
> //  This library is distributed in the hope that it will be useful, 
> //  but WITHOUT ANY WARRANTY; without even the implied warranty of 
> //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
> //  Lesser General Public License for more details. 
> // 
> //  You should have received a copy of the GNU Lesser General Public 
> //  License along with this library; if not, write to the Free Software 
> //  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA 
> // 
> //  See http://www.opencascade.org/SALOME/ or email : webmaster.salome@opencascade.org 
27c27
< //  $Header$
---
> //  $Header$
34c34,36
< #include <BRepAdaptor_Curve.hxx>
---
> #include <TopExp.hxx>
> #include <TopExp_Explorer.hxx>
> 
36c38
< #include <BRepLib_MakeVertex.hxx>
---
> 
39,43c41,47
< #include <Geom_Surface.hxx>
< #include <Precision.hxx>
< #include <TopExp.hxx>
< #include <TopExp_Explorer.hxx>
< #include <TopOpeBRepDS_Transition.hxx>
---
> #include <BRepLib_MakeVertex.hxx>
> #include <BRepAdaptor_Curve.hxx>
> 
> #include <gp_Pnt.hxx>
> #include <TopoDS.hxx>
> #include <TopoDS_Edge.hxx>
> #include <TopoDS_Vertex.hxx>
46c50
< #include <TopTools_ListIteratorOfListOfShape.hxx>
---
> #include <TopOpeBRepDS_Transition.hxx>
48c52
< #include <TopTools_MapIteratorOfMapOfShape.hxx>
---
> #include <TopTools_ListIteratorOfListOfShape.hxx>
50,53c54,57
< #include <TopoDS.hxx>
< #include <TopoDS_Edge.hxx>
< #include <TopoDS_Vertex.hxx>
< #include <gp_Pnt.hxx>
---
> #include <TopTools_MapIteratorOfMapOfShape.hxx>
> 
> #include <stdio.h>
> #include <Precision.hxx>
62,157c66,67
< //function : getOtherShape
< //purpose  :
< //=======================================================================
< 
< static TopoDS_Shape getOtherShape(const TopoDS_Shape&         theS,
<                                   const TopTools_ListOfShape& theSList)
< {
<   TopTools_ListIteratorOfListOfShape anIt( theSList );
<   for ( ; anIt.More(); anIt.Next() )
<     if (!theS.IsSame( anIt.Value() ))
<       return anIt.Value();
< 
<   return TopoDS_Shape();
< }
< 
< //=======================================================================
< //function : findVOnE
< //purpose  : on theE, find a vertex close to theV, such that an edge
< //           passing through it is an itersection of theF1 and theF2.
< //           theE intersects theE2 at theV
< //=======================================================================
< 
< static Standard_Boolean findVOnE(const TopoDS_Vertex &         theV,
<                                  const TopoDS_Edge&            theE,
<                                  const TopoDS_Edge&            theE2,
<                                  const TopoDS_Shape&           theF1,
<                                  const TopoDS_Shape&           theF2,
<                                  const Handle(BRepAlgo_AsDes)& theAsDes,
<                                  TopoDS_Vertex &               theFoundV)
< {
<   Standard_Real MinDist2 = ::RealLast();
<   gp_Pnt P;
< 
<   // check all vertices on theE
<   const TopTools_ListOfShape& aVList = theAsDes->Descendant( theE );
<   TopTools_ListIteratorOfListOfShape anIt( aVList );
<   if (anIt.More())
<     P = BRep_Tool::Pnt( theV );
<   for ( ; anIt.More(); anIt.Next() )
<   {
<     // check by distance
<     TopoDS_Vertex & V = TopoDS::Vertex( anIt.Value() );
<     Standard_Real dist2 = P.SquareDistance( BRep_Tool::Pnt( V ));
<     if (dist2 < MinDist2)
<       MinDist2 = dist2;
<     else
<       continue;
< 
<     // V is a candidate if among edges passing through V there is one
<     // which is an intersection of theF1 and theF2
<     TopTools_ListIteratorOfListOfShape anEIt( theAsDes->Ascendant( V ));
<     Standard_Boolean isOk = Standard_False;
<     for (  ; !isOk && anEIt.More(); anEIt.Next() )
<     {
<       const TopoDS_Shape & E2 = anEIt.Value();
<       if ( theE2.IsSame( E2 ))
<         continue;
<       const TopTools_ListOfShape & aFList = theAsDes->Ascendant( E2 );
<       if (aFList.IsEmpty())
<         continue;
<       if ( theF1.IsSame( aFList.First() ))
<         isOk = theF2.IsSame( aFList.Last() );
<       else
<         isOk = theF2.IsSame( aFList.First() ) && theF1.IsSame( aFList.Last() );
<     }
<     if (isOk)
<       theFoundV = V;
<   }
< 
<   if (theFoundV.IsNull())
<     return Standard_False;
< 
<   // check that MinDist2 is not too large
<   Standard_Real f, l;
<   TopLoc_Location L;
<   Handle(Geom_Curve) aCurve = BRep_Tool::Curve( theE, L, f, l );
<   gp_Pnt P1 = aCurve->Value( f );
<   gp_Pnt P2 = aCurve->Value( 0.3 * f + 0.7 * l );
<   //gp_Pnt P2 = aCurve->Value( 0.5 * ( f + l ));
<   if (MinDist2 > P1.SquareDistance( P2 ))
<     return Standard_False;
< 
< #ifdef DEB
<   cout << "findVOnE: found MinDist = " << sqrt (MinDist2) << endl;
< #endif
< 
<   return Standard_True;
< }
< 
< //=======================================================================
< //function : AddVonE
< //purpose  : Put V in AsDes as intersection of E1 and E2.
< //           Check that vertex equal to V already exists on one
< //           of edges, in  such  a  case,  V  is  not added but
< //           existing vertex is updated to  be on E1 and E2 and
< //           is returned insead of V.
---
> //function : StorePart2d
> //purpose  : 
159a70,75
> // static void  StorePart2d (const TopoDS_Edge&       E1,
> // 			  const TopoDS_Edge&       E2,
> // 			  TopTools_ListOfShape&    LV1,
> // 			  TopTools_ListOfShape&    LV2,
> // 			  Handle(BRepAlgo_AsDes)   AsDes,
> // 			  Standard_Real            Tol)
161,165c77,80
<                                          const TopoDS_Edge&   E1,
<                                          const TopoDS_Edge&   E2,
<                                          const Handle(BRepAlgo_AsDes)& AsDes,
<                                          const TopoDS_Face&   theF)
< 
---
> 					 const TopoDS_Edge&   E1,
> 					 const TopoDS_Edge&   E2,
> 					 const Handle(BRepAlgo_AsDes)& AsDes)
> 					 
173a89,90
>   TopTools_ListOfShape        NewVOnE1;
>   TopTools_ListOfShape        NewVOnE2;
176c93
<   TopTools_ListIteratorOfListOfShape it;
---
>   TopTools_ListIteratorOfListOfShape it, itLV1, itLV2;
183,212c100,114
<   TopoDS_Vertex V    = theV;
< 
<   U1 = BRep_Tool::Parameter(V,E1);
<   U2 = BRep_Tool::Parameter(V,E2);
<   O1 = V.Orientation();
<   O2 = O1;
<   P1  = BRep_Tool::Pnt(V);
<   Tol = BRep_Tool::Tolerance( V );
<   OnE1 = OnE2 = Standard_False;
< 
<   //-----------------------------------------------------------------
<   // Search if the point of intersection is a vertex of E1.
<   //-----------------------------------------------------------------
<   for (it.Initialize(VOnE1); it.More(); it.Next()) {
<     const TopoDS_Vertex& CV = TopoDS::Vertex( it.Value() );
<     if (V.IsSame( CV )) {
<       V1   = V;
<       OnE1 = Standard_True;
<       break;
<     }
<     P2 = BRep_Tool::Pnt( CV );
<     Tol1 = 1.1*(Tol + BRep_Tool::Tolerance( CV ));
<     if (P1.SquareDistance(P2) <= Tol1*Tol1) {
<       V    = CV;
<       V1   = V;
<       OnE1 = Standard_True;
<       break;
<     }
<   }
<   if (OnE1) {
---
> //   for (itLV1.Initialize(LV1),itLV2.Initialize(LV2);
> //        itLV1.More();
> //        itLV1.Next()  ,itLV2.Next()) {
> 
>     TopoDS_Vertex V    = theV;
> //     TopoDS_Vertex V    = TopoDS::Vertex(itLV1.Value());
> 
>     U1 = BRep_Tool::Parameter(V,E1);
>     U2 = BRep_Tool::Parameter(V,E2);
>     O1 = V.Orientation();
>     O2 = O1;///itLV2.Value().Orientation();
>     P1  = BRep_Tool::Pnt(V);
>     Tol = BRep_Tool::Tolerance( V );
>     OnE1 = OnE2 = Standard_False;
>     
214c116
<     // Search if the vertex found is still on E2.
---
>     // Search if the point of intersection is a vertex of E1.
216,219c118,130
<     for (it.Initialize(VOnE2); it.More(); it.Next()) {
<       if (V.IsSame( it.Value() )) {
<         OnE2 = Standard_True;
<         V2   = V;
---
>     for (it.Initialize(VOnE1); it.More(); it.Next()) {
>       const TopoDS_Vertex& CV = TopoDS::Vertex( it.Value() );
>       if (V.IsSame( CV )) {
> 	V1   = V;
>         OnE1 = Standard_True;
>         break;
>       }
>       P2 = BRep_Tool::Pnt( CV );
>       Tol1 = 1.1*(Tol + BRep_Tool::Tolerance( CV ));
>       if (P1.SquareDistance(P2) <= Tol1*Tol1) {
>         V    = CV;
>         V1   = V;
>         OnE1 = Standard_True;
223,225c134
<   }
<   if (!OnE2) {
<     for (it.Initialize(VOnE2); it.More(); it.Next()) {
---
>     if (OnE1) {
227c136
<       // Search if the point of intersection is a vertex of E2.
---
>       // Search if the vertex found is still on E2.
229,236c138,143
<       const TopoDS_Vertex& CV = TopoDS::Vertex( it.Value() );
<       P2 = BRep_Tool::Pnt( CV );
<       Tol2 = 1.1*(Tol + BRep_Tool::Tolerance( CV ));
<       if (P1.SquareDistance(P2) <= Tol2*Tol2) {
<         V  = CV;
<         V2 = V;
<         OnE2 = Standard_True;
<         break;
---
>       for (it.Initialize(VOnE2); it.More(); it.Next()) {
>         if (V.IsSame( it.Value() )) {
>           OnE2 = Standard_True;
>           V2   = V;
>           break;
>         }
239,253c146,160
<   }
< 
< 
<   if (!OnE1 && !OnE2 && !theF.IsNull())
<   {
<     // analitically find vertices E1 and E2 must pass trough
< 
<     TopoDS_Shape F1 = getOtherShape( theF, AsDes->Ascendant( E1 ));
<     TopoDS_Shape F2 = getOtherShape( theF, AsDes->Ascendant( E2 ));
<     if (!F1.IsNull() && !F2.IsNull())
<     {
<       OnE1 = findVOnE ( theV, E1, E2, F1, F2, AsDes, V1 );
<       OnE2 = findVOnE ( theV, E2, E1, F1, F2, AsDes, V2 );
<       if (OnE2) V = V2;
<       if (OnE1) V = V1;
---
>     if (!OnE2) {
>       for (it.Initialize(VOnE2); it.More(); it.Next()) {
>         //-----------------------------------------------------------------
>         // Search if the point of intersection is a vertex of E2.
>         //-----------------------------------------------------------------
>         const TopoDS_Vertex& CV = TopoDS::Vertex( it.Value() );
>         P2 = BRep_Tool::Pnt( CV );
>         Tol2 = 1.1*(Tol + BRep_Tool::Tolerance( CV ));
>         if (P1.SquareDistance(P2) <= Tol2*Tol2) {
>           V  = CV;
>           V2 = V;
>           OnE2 = Standard_True;
>           break;
>         }
>       }
255,272c162,178
<   }
< 
<   if (OnE1 && OnE2) {
<     if (!V1.IsSame(V2)) {
<       // replace V1 with V2 on all edges V1 is on
<       Standard_Real UV1;
<       TopoDS_Edge   EWE1;
<       TopoDS_Vertex VI;
<       const TopTools_ListOfShape& EdgeWithV1 = AsDes->Ascendant(V1);
< 
<       for (it.Initialize(EdgeWithV1); it.More(); it.Next()) {
<         EWE1  = TopoDS::Edge(it.Value());
<         VI = V1;
<         VI.Orientation(TopAbs_INTERNAL);
<         UV1 = BRep_Tool::Parameter(VI,EWE1);
<         VI = V2;
<         VI.Orientation(TopAbs_INTERNAL);
<         B.UpdateVertex( VI, UV1, EWE1, GetTolerance( VI, UV1, EWE1, AsDes));
---
>     if (OnE1 && OnE2) {
>       if (!V1.IsSame(V2)) {
> 	Standard_Real UV2;
> 	TopoDS_Edge   EWE2;
> 	TopoDS_Vertex VI;
> 	const TopTools_ListOfShape& EdgeWithV2 = AsDes->Ascendant(V2);
> 
> 	for (it.Initialize(EdgeWithV2); it.More(); it.Next()) {
> 	  EWE2  = TopoDS::Edge(it.Value());
> 	  VI = V2;
> 	  VI.Orientation(TopAbs_INTERNAL);
> 	  UV2 = BRep_Tool::Parameter(VI,EWE2);
> 	  VI = V1;
> 	  VI.Orientation(TopAbs_INTERNAL);
> 	  B.UpdateVertex(VI,UV2,EWE2, Max(Tol1,Tol2));
> 	}
> 	AsDes->Replace(V2,V1);
274,275d179
<       AsDes->Replace(V1,V2);
<       V = V2;
277,283c181,188
<   }
< 
<   // add existing vertices instead of new ones
<   if (!OnE1) {
<     if (OnE2) {
<       V.Orientation(TopAbs_INTERNAL);
<       B.UpdateVertex (V, U1, E1, GetTolerance( V, U1, E1, AsDes));
---
>     // add existing vertices instead of new ones
>     if (!OnE1) {
>       if (OnE2) {
> 	V.Orientation(TopAbs_INTERNAL);
> 	B.UpdateVertex(V,U1,E1, Tol2);
>       }
>       V.Orientation(O1);
>       NewVOnE1.Prepend(V);
285,291c190,196
<     V.Orientation(O1);
<     AsDes->Add(E1,V);
<   }
<   if (!OnE2) {
<     if (OnE1) {
<       V.Orientation(TopAbs_INTERNAL);
<       B.UpdateVertex (V, U2, E2, GetTolerance( V, U2, E2, AsDes ));
---
>     if (!OnE2) {
>       if (OnE1) {
> 	V.Orientation(TopAbs_INTERNAL);
> 	B.UpdateVertex(V,U2,E2, Tol1);
>       }
>       V.Orientation(O2);
>       NewVOnE2.Prepend(V);
293,295c198,201
<     V.Orientation(O2);
<     AsDes->Add(E2,V);
<   }
---
> //  }
>   
>   if (!NewVOnE1.IsEmpty()) AsDes->Add(E1,NewVOnE1);
>   if (!NewVOnE2.IsEmpty()) AsDes->Add(E2,NewVOnE2);
309,313c215,219
<                                                const Standard_Real f,
<                                                const Standard_Real l,
<                                                const TopoDS_Edge&  E,
<                                                Standard_Boolean&   isFirst,
<                                                Standard_Real&      minDU)
---
> 					       const Standard_Real f,
> 					       const Standard_Real l,
> 					       const TopoDS_Edge&  E,
> 					       Standard_Boolean&   isFirst,
> 					       Standard_Real&      minDU)
335c241
< 
---
>   
345,348c251,254
<                           const Standard_Real f,
<                           const Standard_Real l,
<                           TopTools_ListOfShape& LV1,
<                           TopTools_ListOfShape& /*LV2*/)
---
> 			  const Standard_Real f,
> 			  const Standard_Real l,
> 			  TopTools_ListOfShape& LV1,
> 			  TopTools_ListOfShape& /*LV2*/)
358c264
<   Standard_Real newU;
---
>   Standard_Real newU; 
363c269
< 
---
>   
372c278
< //purpose  :
---
> //purpose  : 
376,380c282,286
<                            const TopoDS_Edge&            E1,
<                            const TopoDS_Edge&            E2,
<                            const Handle(BRepAlgo_AsDes)& AsDes,
<                            const TopTools_MapOfShape&    NewEdges,
<                            const Standard_Boolean        WithOri)
---
> 			   const TopoDS_Edge&            E1,
> 			   const TopoDS_Edge&            E2,
> 			   const Handle(BRepAlgo_AsDes)& AsDes,
> 			   const TopTools_MapOfShape&    NewEdges,
> 			   const Standard_Boolean        WithOri)
386c292
<                            BRep_Tool::Tolerance(E2));
---
> 			   BRep_Tool::Tolerance(E2));
416,419c322,325
<         if (ME.Contains( exp.Current())) {
<           intersect = Standard_False;
<           break;
<         }
---
> 	if (ME.Contains( exp.Current())) {
> 	  intersect = Standard_False;
> 	  break;
> 	}
438,439c344
<     for ( ; EInter.MorePoint(); EInter.NextPoint() )
<     {
---
>     for (;EInter.MorePoint();EInter.NextPoint()) {
451,452c356,363
<       if (sqd1 > MilTol2 || sqd2 > MilTol2  )
<         continue;
---
>       if (sqd1 > MilTol2 || sqd2 > MilTol2  ) {
> 	//MESSAGE ( "Inter2d : Solution rejected, dist: " << sqrt(Max(sqd1,sqd2)) )
> #ifdef DEB
> 	if (TestEdges) {
> 	  MESSAGE ( " edges : E2d_"<<NbE2d-2<<" E2d_"<<NbE2d-1 ); }
> #endif
> 	continue;
>       }
455c366
<       Standard_Real toler = Max( Tol, sqrt( Max( sqd1, sqd2 )));
---
>       Standard_Real toler = 1.5 * Max (Tol, sqrt(Max(sqd1,sqd2)) );
458,469c369,385
<         Standard_Real U = P2D.Parameter(i);
<         V.Orientation(TopAbs_INTERNAL);
<         B.UpdateVertex( V,U,EI[i], toler);
<         TopAbs_Orientation OO = TopAbs_REVERSED;
<         if (WithOri) {
<           if (P2D.IsVertex(i))
<             OO = P2D.Vertex(i).Orientation();
<           else if (P2D.Transition(i).Before() == TopAbs_OUT) {
<             OO = TopAbs_FORWARD;
<           }
<           V.Orientation(OO);
<           if (i == 1) LV1.Append(V);
---
> 	Standard_Real U = P2D.Parameter(i);
> #ifdef DEB
> 	if (U < f[i]-Tol  || U > l[i]+Tol) {
> 	  MESSAGE ( "out" );
> 	}
> #endif
> 	V.Orientation(TopAbs_INTERNAL);
> 	B.UpdateVertex( V,U,EI[i], toler);
> 	TopAbs_Orientation OO = TopAbs_REVERSED;
> 	if (WithOri) {
> 	  if (P2D.IsVertex(i)) 
> 	    OO = P2D.Vertex(i).Orientation();
> 	  else if (P2D.Transition(i).Before() == TopAbs_OUT) {
> 	    OO = TopAbs_FORWARD;
> 	  }
> 	  V.Orientation(OO);
> 	  if (i == 1) LV1.Append(V);
497c413
<         TolConf2 *= 100;
---
> 	TolConf2 *= 100;
529,530c445
<          it1LV1.More();
<          it1LV1.Next(),it1LV2.Next()) {
---
>          it1LV1.More(); it1LV1.Next(),it1LV2.Next()) {
534,537c449,452
<         const TopoDS_Vertex& VE1 = TopoDS::Vertex(it1LV1.Value());
<         const TopoDS_Vertex& VE2 = TopoDS::Vertex(it2LV1.Value());
<         Standard_Real Tol1 = BRep_Tool::Tolerance( VE1 );
<         Standard_Real Tol2 = BRep_Tool::Tolerance( VE2 );
---
> 	const TopoDS_Vertex& VE1 = TopoDS::Vertex(it1LV1.Value());
> 	const TopoDS_Vertex& VE2 = TopoDS::Vertex(it2LV1.Value());
> 	Standard_Real Tol1 = BRep_Tool::Tolerance( VE1 );
> 	Standard_Real Tol2 = BRep_Tool::Tolerance( VE2 );
543,547c458,465
<           Purge = Standard_True;
<           break;
<         }
<         j++;
<         it2LV1.Next();
---
>           if (AffichPurge) {
>             MESSAGE ("Vertices confused purged in EdgeInter.")
>             }
> 	  Purge = Standard_True;
> 	  break;
> 	}
> 	j++;
> 	it2LV1.Next();
556c474
<     treatClosed (E1, f[1], l[1], LV1, LV2);
---
>     treatClosed (E1,f[1],l[1],LV1,LV2);
558,562c476,480
<     treatClosed (E2, f[2], l[2], LV2, LV1);
< 
<   //----------------
<   // Stocking vertex
<   //----------------
---
>     treatClosed (E2,f[2],l[2],LV2,LV1);
>   
>   //---------------------------------
>   // Stocking vertex .
>   //---------------------------------  
563a482
>   //StorePart2d (E1,E2,LV1,LV2,AsDes,Tol);
565,566c484
<     Partition_Inter2d::AddVonE (TopoDS::Vertex( it1LV1.Value()),
<                                 E1, E2, AsDes, F);
---
>     Partition_Inter2d::AddVonE ( TopoDS::Vertex( it1LV1.Value()), E1,E2,AsDes);
577,578c495,496
<                                        const TopoDS_Face&              F,
<                                        const TopTools_MapOfShape&      NewEdges)
---
> 				       const TopoDS_Face&              F,
> 				       const TopTools_MapOfShape&      NewEdges)
602c520
< 
---
>   
618,619c536,537
<            (NewEdges.Contains(E1) || NewEdges.Contains(E2)) ) {
<         EdgesPartition(FF,E1,E2,AsDes,NewEdges,Standard_True);
---
> 	   (NewEdges.Contains(E1) || NewEdges.Contains(E2)) ) {
> 	EdgesPartition(FF,E1,E2,AsDes,NewEdges,Standard_True);
628,670d545
< //=======================================================================
< //function : GetTolerance
< //purpose  : Returns  tolerance  theV   must   have  atfer  its
< //           addition to theE with  theU parameter. theAsDes is
< //           used to find pcurves of theE
< //=======================================================================
< 
< Standard_Real Partition_Inter2d::GetTolerance
<                          (const TopoDS_Vertex &         theV,
<                           const Standard_Real           theU,
<                           const TopoDS_Edge &           theE,
<                           const Handle(BRepAlgo_AsDes)& theAsDes)
< {
<   Standard_Real aTol = BRep_Tool::Tolerance( theV );
<   gp_Pnt aPnt = BRep_Tool::Pnt( theV );
< 
<   // check point on 3D curve
<   Standard_Real f,l;
<   Handle(Geom_Curve) C = BRep_Tool::Curve( theE, f, l );
<   if (!C.IsNull())
<     aTol = Max ( aTol, aPnt.Distance( C->Value( theU )));
< 
<   // check points on pcurves
<   const TopTools_ListOfShape& aFList = theAsDes->Ascendant( theE );
<   TopTools_ListIteratorOfListOfShape aFIt( aFList );
<   for (  ; aFIt.More(); aFIt.Next() )
<   {
<     const TopoDS_Face& F = TopoDS::Face( aFIt.Value() );
<     Handle(Geom2d_Curve) pcurve = BRep_Tool::CurveOnSurface( theE, F, f, l );
<     if (!pcurve.IsNull())
<     {
<       gp_Pnt2d aPnt2d = pcurve->Value( theU );
<       TopLoc_Location L;
<       Handle(Geom_Surface) S = BRep_Tool::Surface( F, L );
<       gp_Pnt aPntOnS = S->Value( aPnt2d.X(), aPnt2d.Y() );
<       if (!L.IsIdentity())
<         aPntOnS.Transform( L.Transformation() );
<       aTol = Max ( aTol, aPnt.Distance( aPntOnS ));
<     }
<   }
< 
<   return aTol;
< }
diff -r ../src/PARTITION/Partition_Inter2d.hxx ../../../GEOM_SRC/src/PARTITION/Partition_Inter2d.hxx
74,75c74,75
< Standard_EXPORT static  TopoDS_Vertex AddVonE(const TopoDS_Vertex& V,const TopoDS_Edge& E1,const TopoDS_Edge& E2,const Handle(BRepAlgo_AsDes)& AsDes,const TopoDS_Face& F) ;
< Standard_EXPORT static  Standard_Real GetTolerance(const TopoDS_Vertex& theV,const Standard_Real theU,const TopoDS_Edge& theE,const Handle(BRepAlgo_AsDes)& theAsDes) ;
---
> Standard_EXPORT static  TopoDS_Vertex AddVonE(const TopoDS_Vertex& V,const TopoDS_Edge& E1,const TopoDS_Edge& E2,const Handle(BRepAlgo_AsDes)& AsDes) ;
> 
diff -r ../src/PARTITION/Partition_Inter3d.cdl ../../../GEOM_SRC/src/PARTITION/Partition_Inter3d.cdl
71,76c71
<         ---Purpose: return map of faces cut by new or section edges
< 
<     NewEdges(me : in out) returns MapOfShape from TopTools
<         ---C++:  return &
<         is static;
<         ---Purpose: return new and section edges
---
>         ---Purpose: return map of 
80,84d74
<         ---Purpose: return an object containing info about
<         --             Ascendants     | Descendants
<         --          ------------------+---------------------
<         --          1. faces          | edges cutting them
<         --          2. sectoin edges  | new vertices on them
85a76,78
>     NewEdges(me : in out) returns MapOfShape from TopTools
>         ---C++:  return &
>         is static;
diff -r ../src/PARTITION/Partition_Inter3d.cxx ../../../GEOM_SRC/src/PARTITION/Partition_Inter3d.cxx
27c27
< //  $Header$
---
> //  $Header$
30d29
< #include "Partition_Inter2d.hxx"
31a31
> #include "Partition_Inter2d.hxx"
34,36d33
< #include <BRepAlgo_AsDes.hxx>
< #include <BRepAlgo_Image.hxx>
< #include <BRepLib.hxx>
39a37,39
> #include <BRepAlgo_AsDes.hxx>
> #include <BRepAlgo_Image.hxx>
> #include <BRepLib.hxx>
44,47d43
< #include <TopOpeBRepTool_BoxSort.hxx>
< #include <TopTools_DataMapIteratorOfDataMapOfShapeListOfShape.hxx>
< #include <TopTools_ListIteratorOfListOfShape.hxx>
< #include <TopTools_ListOfShape.hxx>
49c45
< #include <TopoDS_Compound.hxx>
---
> #include <TopoDS_Vertex.hxx>
52c48,52
< #include <TopoDS_Vertex.hxx>
---
> #include <TopoDS_Compound.hxx>
> #include <TopTools_ListOfShape.hxx>
> #include <TopTools_ListIteratorOfListOfShape.hxx>
> #include <TopTools_DataMapIteratorOfDataMapOfShapeListOfShape.hxx>
> #include <TopOpeBRepTool_BoxSort.hxx>
58,74c58,62
< #include <BRepLib_MakeVertex.hxx>
< #include <BRepTools.hxx>
< #include <Extrema_ExtPS.hxx>
< #include <Extrema_POnSurf.hxx>
< #include <Geom2dAPI_ProjectPointOnCurve.hxx>
< #include <Geom2d_Curve.hxx>
< #include <GeomAPI_ProjectPointOnCurve.hxx>
< #include <GeomAdaptor_Surface.hxx>
< #include <Geom_Curve.hxx>
< #include <Geom_RectangularTrimmedSurface.hxx>
< #include <Geom_SphericalSurface.hxx>
< #include <Geom_Surface.hxx>
< #include <Geom_ToroidalSurface.hxx>
< #include <Geom_TrimmedCurve.hxx>
< #include <Precision.hxx>
< #include <TColStd_MapOfInteger.hxx>
< #include <TopOpeBRepBuild_Builder.hxx>
---
> #include <stdio.h>
> #include <TopOpeBRepDS_HDataStructure.hxx>
> #include <TopOpeBRep_DSFiller.hxx>
> #include <TopOpeBRepTool_GeomTool.hxx>
> #include <TopOpeBRepTool_OutCurveType.hxx>
75a64
> #include <TopOpeBRepBuild_Builder.hxx>
77,78c66
< #include <TopOpeBRepDS_HDataStructure.hxx>
< #include <TopOpeBRepDS_Interference.hxx>
---
> #include <Geom2d_Curve.hxx>
80a69
> #include <Geom_Curve.hxx>
82,84c71
< #include <TopOpeBRepTool_GeomTool.hxx>
< #include <TopOpeBRepTool_OutCurveType.hxx>
< #include <TopOpeBRep_DSFiller.hxx>
---
> #include <TopOpeBRepDS_Interference.hxx>
86c73,81
< #include <stdio.h>
---
> #include <BRepLib_MakeVertex.hxx>
> #include <Precision.hxx>
> #include <TColStd_MapOfInteger.hxx>
> #include <BRepTools.hxx>
> #include <Geom_RectangularTrimmedSurface.hxx>
> #include <Geom_Surface.hxx>
> #include <Geom_TrimmedCurve.hxx>
> #include <Geom2dAPI_ProjectPointOnCurve.hxx>
> #include <GeomAPI_ProjectPointOnCurve.hxx>
199,248d193
<   if (!S->IsUPeriodic() && !S->IsVPeriodic())
<     return;
< 
<   BRepTools::UVBounds(F,umin,umax,vmin,vmax);
< 
<   gp_Pnt2d Pf = C2d->Value(f);
<   gp_Pnt2d Pl = C2d->Value(l);
<   const Standard_Real Um = 0.34*f + 0.66*l;
<   gp_Pnt2d Pm = C2d->Value( Um );
< 
<   // sometimes on shpere, pcurve is out of domain by V though S is
<   // UPeriodic, sometimes it is in domain but nontheless it has
<   // wrong position.
<   // Check pcurve position by 3D point
<   if (S->IsKind(STANDARD_TYPE( Geom_SphericalSurface )) ||
<       S->IsKind(STANDARD_TYPE( Geom_ToroidalSurface )))
<   {
<     // get point on the surface
<     gp_Pnt Ps = S->Value( Pm.X(), Pm.Y() );
<     // get point on the edge
<     Handle(Geom_Curve) C = BRep_Tool::Curve( E, f, l );
<     gp_Pnt Pc = C->Value( Um );
<     // compare points
<     Standard_Real TolE = BRep_Tool::Tolerance( E );
<     if ( Pc.SquareDistance( Ps ) * 0.95 < TolE * TolE )
<       return; // OK
< 
<     // find good UV for Pc: project Pc on S
<     GeomAdaptor_Surface  SA (S);
<     Extrema_ExtPS anExtPS (Pc, SA,
<                            SA.UResolution( TolE ), SA.VResolution( TolE ));
<     if (anExtPS.IsDone())
<     {
<       Standard_Integer i, nbExt = anExtPS.NbExt();
<       Extrema_POnSurf aPOnSurf;
<       for (i = 1; i <= nbExt; ++i )
<         if (anExtPS.Value( i ) <= TolE) {
<           aPOnSurf = anExtPS.Point( i );
<           break;
<         }
<       if (i <= nbExt) {
<         // a point found
<         Standard_Real u, v;
<         aPOnSurf.Parameter( u, v );
<         gp_Pnt2d aGoodPm ( u, v );
<         C2d->Translate( Pm , aGoodPm );
<       }
<     }
<   }
< 
251a197,200
>   if (!S->IsUPeriodic() && !S->IsVPeriodic()) return;
> 
>   BRepTools::UVBounds(F,umin,umax,vmin,vmax);
> 
254a204,206
>     gp_Pnt2d      Pf      = C2d->Value(f);
>     gp_Pnt2d      Pl      = C2d->Value(l);
>     gp_Pnt2d      Pm      = C2d->Value(0.34*f + 0.66*l);
285a238,240
>     gp_Pnt2d      Pf      = C2d->Value(f);
>     gp_Pnt2d      Pl      = C2d->Value(l);
>     gp_Pnt2d      Pm      = C2d->Value(0.34*f + 0.66*l);
356a312,313
> //       Standard_Real f,l;
> //       BRep_Tool::Range(E,f,l);
373,375c330,332
<   // ========================
<   // store same domain faces 
<   // ========================
---
>   // ===================================================
>   // Store section edges, same domain faces and verives
>   // ===================================================
376a334
>   TopTools_ListOfShape empty, LSP, LSE;
378,380c336
<   if ( DatStr->HasSameDomain( F1 ))
<   {
<     TopTools_ListOfShape emptyList;
---
>   if ( DatStr->HasSameDomain( F1 )) { // same domain faces
382c338
<       mySameDomainFM.Bind(F1,emptyList);
---
>       mySameDomainFM.Bind(F1,empty);
384c340
<       mySameDomainFM.Bind(F2,emptyList);
---
>       mySameDomainFM.Bind(F2,empty);
389,392d344
<   // ====================
<   // Store section edges
<   // ====================
< 
394,395c346,347
<   Standard_Integer j,i,nse = DS.NbSectionEdges();
<   if (nse == 0) return;
---
>   Standard_Integer j,i,nes = DS.NbSectionEdges();
>   if (!nes) return;
400,401d351
<   TopTools_ListOfShape LSE; // list of section edges
<   TopoDS_Face dummyF;
403,405c353,357
<   for (i = 1; i <= nse; i++)
<   {
<     const TopoDS_Edge & se = DS.SectionEdge(i);
---
>   // put vertices on section edges
>   for (i=1;i<=nes;i++) {
> 
>     TopoDS_Edge se, sde, oe; // section, same domain, other edge
>     se = DS.SectionEdge(i);
408d359
<     LSE.Append( se );
410,413d360
<     // add vertices where section edges interferes with other
<     // edges as its descendant in myAsDes
<     
<     TopoDS_Edge sde, oe; // same domain, other edge
418c365,366
<     TColStd_MapOfInteger MIV; // indices of added edges
---
>     
>     TColStd_MapOfInteger MIV;
421d368
<     // loop on intersections of se
425d371
<         // there is a vertex at intersection
433c379
< 	B.UpdateVertex( V, itP.Parameter(), se, 0.); // AddVonE() sets real U
---
> 	B.UpdateVertex( V, itP.Parameter(), se, 0.);
436d381
<         // create a new vertex at the intersection point
451,452c396
<       // add V on the both intersecting edges
<       TopoDS_Vertex addedV = Partition_Inter2d::AddVonE( V,se,oe,myAsDes,dummyF);
---
>       TopoDS_Vertex addedV = Partition_Inter2d::AddVonE( V,se,oe,myAsDes);
454,456c398,399
< 	mySameDomainVM.Bind (V, addedV); // equal vertex is already there
< 
<       MV.Add( addedV ); // to ease storage of vertices of ON splits
---
> 	mySameDomainVM.Bind (V, addedV);
>       MV.Add( addedV );
460,463c403
<   // add section edge to the face it intersects and find
<   // splits ON that do not have same domain pair
<   
<   TopB.SplitSectionEdges(); // let TopB find ON splits
---
>   TopB.SplitSectionEdges();
465c405
<   TopTools_MapOfShape SPM; // map of ON splits
---
>   TopTools_DataMapOfShapeShape SEM; // map split - section edge
470,471c410,413
<   TopTools_ListIteratorOfListOfShape itSP, itLSE (LSE);
<   while ( itLSE.More() ) {
---
>   // add section edge to the face it intersects and find
>   // splits ON that do not have same domain pair
>   
>   for (i=1;i<=nes;i++) {
473c415,417
<     TopoDS_Edge se = TopoDS::Edge( itLSE.Value() );
---
>     const TopoDS_Edge& se = DS.SectionEdge(i);
>     if (! TopB.IsSplit(se,TopAbs_ON))
>       continue;
477,479c421
<       LSE.Remove( itLSE ); // se is an edge of face it intersects
<     else
<       itLSE.Next();
---
>       continue; // se is an edge of face it intersects
484c426
<     TopTools_ListIteratorOfListOfShape itE( myAsDes->Descendant( F ));
---
>     TopTools_ListIteratorOfListOfShape itE;
486c428
<       for ( ; itE.More(); itE.Next())
---
>       for (itE.Initialize( (myAsDes->Descendant( F )) ); itE.More(); itE.Next())
490,491c432
<     if (!itE.More())
<     {
---
>     if (!itE.More()) {
493,494d433
< 
<       // check se pcurve on F
498,500c437,439
< 	itSP.Initialize( TopB.Splits(se,TopAbs_ON) );
< 	for ( ; itSP.More(); itSP.Next()) {
< 	  const TopoDS_Edge& E = TopoDS::Edge ( itSP.Value());
---
> 	TopTools_ListIteratorOfListOfShape it( TopB.Splits(se,TopAbs_ON) );
> 	for ( ;it.More();it.Next()) {
> 	  const TopoDS_Edge& E = TopoDS::Edge ( it.Value());
515c454
< 
---
> 	
517,522c456,462
<     // ie which split a face into parts and not pass by its boundary
<     itSP.Initialize( TopB.Splits(se,TopAbs_ON) );
<     for ( ; itSP.More(); itSP.Next()) {
<       const TopoDS_Shape& SP = itSP.Value();
<       if (!SPM.Add( SP ))
< 	SPM.Remove( SP );
---
>     TopTools_ListIteratorOfListOfShape it( TopB.Splits(se,TopAbs_ON) );
>     for ( ;it.More();it.Next()) {
>       const TopoDS_Edge& S = TopoDS::Edge ( it.Value());
>       if (SEM.IsBound( S ))
> 	SEM.UnBind( S );
>       else 
> 	SEM.Bind( S, se);
527,530c467,471
<   
<   for (itLSE.Initialize (LSE); itLSE.More(); itLSE.Next())
<   {
<     const TopoDS_Shape& se = itLSE.Value();
---
>   for (i=1;i<=nes;i++) {
> 
>     const TopoDS_Edge& se = DS.SectionEdge(i);
>     if (! TopB.IsSplit(se,TopAbs_ON))
>       continue;
532a474,476
>     if (ME[ancRank-1].Contains( se ))
>       continue; // se is an edge of face it intersects
> 
535c479
<     // add vertices of ON splits which have no same domain pair
---
>     // add vertices of splits
537,540c481,484
<     itSP.Initialize( TopB.Splits(se,TopAbs_ON) );
<     for ( ; itSP.More(); itSP.Next())
<     {
<       if (!SPM.Contains( itSP.Value() ))
---
>     TopTools_ListIteratorOfListOfShape it( TopB.Splits(se,TopAbs_ON) );
>     for ( ;it.More();it.Next()) {
>       const TopoDS_Edge& S = TopoDS::Edge ( it.Value());
>       if (!SEM.IsBound( S ))
542,543d485
<       
<       const TopoDS_Edge& S = TopoDS::Edge ( itSP.Value());
550,551c492
<       for (j=0; j<2; ++j)
<       {
---
>       for (j=0; j<2; ++j) {
560,561d500
<             if ( V.IsSame( VS[j] ))
<               break;
572,574d510
< 
<         // add ends of ON splits to F in order to detect later
<         // if a split is on face in IsSplitOn()
577,578d512
<       // in the descendants of F, first go ends of an ON split and
<       // then a split itself
613,614c547,548
<     TopTools_ListOfShape emptyList;
<     myDone.Bind(F1,emptyList);
---
>     TopTools_ListOfShape empty;
>     myDone.Bind(F1,empty);
618,619c552,553
<     TopTools_ListOfShape emptyList;
<     myDone.Bind(F2,emptyList);
---
>     TopTools_ListOfShape empty;
>     myDone.Bind(F2,empty);
651a586
> 
741,742c676,677
<   static TopTools_ListOfShape emptyList;
<   return emptyList;
---
>   static TopTools_ListOfShape empty;
>   return empty;
diff -r ../src/PARTITION/Partition_Loop2d.cxx ../../../GEOM_SRC/src/PARTITION/Partition_Loop2d.cxx
3c3
< //  Copyright (C) 2003  CEA/DEN, EDF R& D
---
> //  Copyright (C) 2003  CEA/DEN, EDF R&D
10c10
< //  $Header$
---
> //  $Header$
21d20
< #include <BRepAlgo_FaceRestrictor.hxx>
120,172d118
< //function : preciseU
< //purpose  : find u such that the 3D point on theE is just out of tolerance
< //           of theV
< //=======================================================================
< 
< static Standard_Real preciseU (const BRepAdaptor_Surface&  theSurf,
<                                const TopoDS_Edge&          theE,
<                                const TopoDS_Vertex&        theV,
<                                const Handle(Geom2d_Curve)& theC,
<                                const Standard_Boolean      theFirstEnd)
< {
<   Standard_Boolean isForward = ( theE.Orientation () == TopAbs_FORWARD );
<   if (theFirstEnd) isForward = !isForward;
< 
<   // find the first point in 2d and 3d
<   Standard_Real f,l;
<   BRep_Tool::Range( theE, f, l );
<   Standard_Real u0 = isForward ? l : f;
<   gp_Pnt2d aP2d0 = theC->Value( u0 );
<   gp_Pnt aPnt0 = theSurf.Value( aP2d0.X(), aP2d0.Y() );
< 
<   // shift in 2d and 3d
<   Standard_Real du = ( l - f ) / 100, du3d = 0;
<   if (isForward)
<     du = -du;
< 
<   // target parameter
<   Standard_Real u;
< 
<   while (du3d < ::RealSmall())
<   {
<     // u for test
<     u = u0 + du;
<     du *= 10; // for the next iteration: increase du untill du3d is large enough
< 
<     // find out how u is far from u0 in 3D
<     gp_Pnt2d aP2d  = theC->Value( u );
<     gp_Pnt aPnt  = theSurf.Value( aP2d.X(), aP2d.Y() );
<     du3d = aPnt0.Distance( aPnt );
<   }
< 
<   // find u such that the 3D point is just out of tolerance of theV
<   Standard_Real tolV = BRep_Tool::Tolerance( theV ) + Precision::Confusion();
<   u = u0 + du * tolV / du3d;
< 
<   // check that u is within the range
<   if ( isForward ? (u < f) : (u > l) )
<     u = u0 + du;
< 
<   return u;
< }
< 
< //=======================================================================
174,177c120,122
< //purpose  : Find in the list <LE> the edge <NE> connected with <CE> by
< //           the vertex <CV>.
< //           <NE> is removed from the list. If <CE> is in <LE>
< //           with the same orientation, it's removed from the list
---
> //purpose  : Find the edge <NE> connected <CE> by the vertex <CV> in the list <LE>.
> //           <NE> Is erased  of the list. If <CE> is too in the list <LE>
> //           with the same orientation, it's erased of the list
181,184c126,129
<                                     const TopoDS_Edge&    CE,
<                                     const TopoDS_Vertex&  CV,
<                                     TopoDS_Edge&          NE,
<                                     const TopTools_ListOfShape& LE)
---
> 				    const TopoDS_Edge&    CE,
> 				    const TopoDS_Vertex&  CV,
> 				    TopoDS_Edge&          NE,
> 				    const TopTools_ListOfShape& LE)
194d138
<     TopoDS_Edge aPrevNE;
196,199c140
<     gp_Vec2d CTg1, Tg1, CTg2, Tg2;
<     gp_Pnt2d PC, P;
< 
<     Standard_Real f, l;
---
>     Standard_Real   cf, cl, f, l;
201c142,156
<     Cc = BRep_Tool::CurveOnSurface(CE,FForward,f,l);
---
>     Cc = BRep_Tool::CurveOnSurface(CE,FForward,cf,cl);
> 
> //    Standard_Real tolV, tol2d2;
>     Standard_Real tolV = BRep_Tool::Tolerance(CV);
> //     tol2d2 = Max ( Surf.UResolution(tolV) , Surf.VResolution(tolV) );
> //     tol2d2 = 2 * Max ( tol2d2, Precision::PConfusion() );
> //     tol2d2 *= tol2d2;
> 
>     Standard_Real uc,u, du = Precision::PConfusion();
>     if (CE.Orientation () == TopAbs_FORWARD) uc = cl + du;
>     else                                     uc = cf - du;
> 
>     gp_Vec2d CTg1, Tg1;
>     gp_Pnt2d PC, P;
>     gp_Pnt P3d;
203,205d157
<     Standard_Boolean isForward = ( CE.Orientation () == TopAbs_FORWARD );
<     Standard_Real uc, u, du = Precision::PConfusion();
<     uc = isForward ? ( l - du ) : ( f + du );
207c159
<     if (!isForward) CTg1.Reverse();
---
>     if (CE.Orientation () == TopAbs_REVERSED) CTg1.Reverse();
209c161,162
<     Standard_Real anglemin = 3 * PI, tolAng = 1.e-8;
---
>     Standard_Real anglemin = 3 * PI;
> //    Standard_Real sqdist, sqdistmin = 1.0e50;
211,212d163
<     // select an edge whose first derivative is most left of CTg1
<     // ie an angle between Tg1 and CTg1 is least
217c168
<         continue;
---
> 	continue;
219,221c170
<         continue;
< 
<       isForward = ( E.Orientation () == TopAbs_FORWARD );
---
> 	continue;
223d171
<       // get E curve
225,228c173,174
<       // get the first derivative Tg1
<       u = isForward ? ( f + du ) : ( l - du );
<       C->D1(u, P, Tg1);
<       if (!isForward) Tg1.Reverse();
---
>       if (E.Orientation () == TopAbs_FORWARD) u = f + du;
>       else                                    u = l - du;
230,231c176,178
<       // -PI < angle < PI
<       Standard_Real angle = Tg1.Angle(CTg1);
---
>       C->D1(u, P, Tg1);
> //       if (P.SquareDistance(PC); > tol2d2)
> // 	  continue;
233,245c180
<       if (PI - Abs(angle) <= tolAng)
<       {
<         // an angle is too close to PI; assure that an angle sign really
<         // reflects an edge position: +PI - an edge is worst,
<         // -PI - an edge is best.
<         u = preciseU( Surf, CE, CV, Cc, Standard_False);
<         gp_Vec2d CTg;
<         Cc->D1(u, PC, CTg);
<         if (CE.Orientation() == TopAbs_REVERSED) CTg.Reverse();
< 
<         u = preciseU( Surf, E, CV, C, Standard_True);
<         C->D1(u, P, Tg1);
<         if (!isForward) Tg1.Reverse();
---
>       if (E.Orientation () == TopAbs_REVERSED) Tg1.Reverse();
247,248c182
<         angle = Tg1.Angle(CTg);
<       }
---
>       Standard_Real angle = Tg1.Angle(CTg1);
250d183
<       Standard_Boolean isClose = ( Abs( angle - anglemin ) <= tolAng );
252,257c185,192
<         if (isClose)
<           aPrevNE = NE;
<         else
<           aPrevNE.Nullify();
<         anglemin = angle ;
<         NE = E;
---
> 	anglemin = angle ;
> 	NE = E;
> #ifdef DEB
> // 	sqdist = P.SquareDistance(PC);
> // 	if (sqdist < sqdistmin)
> // 	  sqdistmin = sqdist;
> 	P3d = Surf.Value (PC.X(), PC.Y());
> #endif
259,262d193
<       else
<         if (isClose)
<           aPrevNE = E;
< 
264,276c195,198
<     if (!aPrevNE.IsNull()) {
<       // select one of close edges, the most left one.
<       Cc = BRep_Tool::CurveOnSurface( NE, FForward, f, l );
<       uc = preciseU( Surf, NE, CV, Cc, Standard_True);
<       Cc->D1(uc, PC, CTg1);
<       if (NE.Orientation() != TopAbs_FORWARD) CTg1.Reverse();
<       
<       u = preciseU( Surf, aPrevNE, CV, C, Standard_True);
<       C->D1(u, P, Tg1);
<       if (aPrevNE.Orientation() != TopAbs_FORWARD) Tg1.Reverse();
< 
<       if ( Tg1.Angle(CTg1) < 0)
<         NE = aPrevNE;
---
> #ifdef DEB
>     if (!NE.IsNull() && P3d.Distance( BRep_Tool::Pnt(CV)) > tolV) {
>       MESSAGE( "DISTANCE MORE THAN VERTEX TOL (" << tolV << ")" );
>       cout << "point p " << P3d.X() << " " << P3d.Y() << " " << P3d.Z() << endl;
277a200
> #endif
294,297c217,220
<                                    const TopoDS_Edge&   E1,
<                                    const TopoDS_Vertex& V2,
<                                    const TopoDS_Edge&   E2,
<                                    const TopoDS_Face&   F)
---
> 				   const TopoDS_Edge&   E1,
> 				   const TopoDS_Vertex& V2,
> 				   const TopoDS_Edge&   E2,
> 				   const TopoDS_Face&   F)
318,319c241,242
<                         TopoDS_Edge& E,
<                         TopTools_DataMapOfShapeListOfShape& MVE )
---
> 			TopoDS_Edge& E,
> 			TopTools_DataMapOfShapeListOfShape& MVE )
339c262
< //purpose  :
---
> //purpose  : 
343c266
<                           TopTools_DataMapOfShapeListOfShape& MVE)
---
> 			  TopTools_DataMapOfShapeListOfShape& MVE)
351,352c274,275
<         MVE(V1).Remove(itl);
<         break;
---
> 	MVE(V1).Remove(itl);
> 	break;
358,359c281,282
<         MVE(V2).Remove(itl);
<         break;
---
> 	MVE(V2).Remove(itl);
> 	break;
369,371c292,294
<                          TopTools_MapOfShape& EM,
<                          TopTools_MapOfShape& VM,
<                          const TopTools_DataMapOfShapeListOfShape& MVE)
---
> 			 TopTools_MapOfShape& EM,
> 			 TopTools_MapOfShape& VM,
> 			 const TopTools_DataMapOfShapeListOfShape& MVE)
378c301
< 
---
>     
383c306
<         addConnected ( itE.Value(), EM, VM, MVE );
---
> 	addConnected ( itE.Value(), EM, VM, MVE );
392,416c315,339
< // static Standard_Boolean canPassToOld (const TopoDS_Shape& V,
< //                                    TopTools_MapOfShape& UsedShapesMap,
< //                                    const TopTools_DataMapOfShapeListOfShape& MVE,
< //                                    const TopTools_MapOfShape& SectionEdgesMap)
< // {
< //   TopTools_ListIteratorOfListOfShape itE( MVE(V) );
< //   // Loop on edges sharing V
< //   for (; itE.More(); itE.Next()) {
< //     if ( !UsedShapesMap.Add( itE.Value() ))
< //       continue; // already checked
< 
< //     if ( !SectionEdgesMap.Contains( itE.Value() ))
< //       return Standard_True; // WE PASSED
< 
< //     TopoDS_Iterator itV( itE.Value() );
< //     // Loop on vertices of an edge
< //     for (; itV.More(); itV.Next()) {
< //       if ( !UsedShapesMap.Add( itV.Value() ))
< //      continue; // already checked
< //       else
< //      return canPassToOld( itV.Value(), UsedShapesMap, MVE, SectionEdgesMap);
< //     }
< //   }
< //   return Standard_False;
< // }
---
> static Standard_Boolean canPassToOld (const TopoDS_Shape& V,
> 				      TopTools_MapOfShape& UsedShapesMap,
> 				      const TopTools_DataMapOfShapeListOfShape& MVE,
> 				      const TopTools_MapOfShape& SectionEdgesMap)
> {
>   TopTools_ListIteratorOfListOfShape itE( MVE(V) );
>   // Loop on edges sharing V
>   for (; itE.More(); itE.Next()) {
>     if ( !UsedShapesMap.Add( itE.Value() ))
>       continue; // already checked
> 
>     if ( !SectionEdgesMap.Contains( itE.Value() ))
>       return Standard_True; // WE PASSED
> 
>     TopoDS_Iterator itV( itE.Value() );
>     // Loop on vertices of an edge
>     for (; itV.More(); itV.Next()) {
>       if ( !UsedShapesMap.Add( itV.Value() ))
> 	continue; // already checked
>       else
> 	return canPassToOld( itV.Value(), UsedShapesMap, MVE, SectionEdgesMap);
>     }
>   }
>   return Standard_False;
> }
426,430c349,353
<                                       const TopoDS_Vertex& CV,
<                                       TopoDS_Edge& NE,
<                                       TopTools_SequenceOfShape& EdgesSeq,
<                                       TColStd_SequenceOfReal& USeq,
<                                       const TopoDS_Edge& DE)
---
> 				      const TopoDS_Vertex& CV,
> 				      TopoDS_Edge& NE,
> 				      TopTools_SequenceOfShape& EdgesSeq,
> 				      TColStd_SequenceOfReal& USeq,
> 				      const TopoDS_Edge& DE)
458c381
<         continue;
---
> 	continue;
497,502c420,425
<                           const TopoDS_Face&                        F,
<                           const TopTools_DataMapOfShapeListOfShape& MVE,
<                           TopTools_SequenceOfShape&                 EdgesSeq,
<                           TColStd_SequenceOfReal&                   USeq,
<                           TopTools_DataMapOfShapeInteger&           MVDEI,
<                           const Standard_Integer                    DegEdgeIndex)
---
> 			  const TopoDS_Face&                        F,
> 			  const TopTools_DataMapOfShapeListOfShape& MVE,
> 			  TopTools_SequenceOfShape&                 EdgesSeq,
> 			  TColStd_SequenceOfReal&                   USeq,
> 			  TopTools_DataMapOfShapeInteger&           MVDEI,
> 			  const Standard_Integer                    DegEdgeIndex)
536c459
<         first = Standard_False;
---
> 	first = Standard_False;
538c461
<         first = !first;
---
> 	first = !first;
550,551c473,474
<         MESSAGE ( "NO 2d INTERSECTION ON DEGENERATED EDGE" );
<         continue;
---
> 	MESSAGE ( "NO 2d INTERSECTION ON DEGENERATED EDGE" );
> 	continue;
646c569
<         WEL.Append( CE );
---
> 	WEL.Append( CE );
648,652c571,575
<         doubleEM.Add( CE );
<         RemoveFromMVE (CE,MVE2);
<         TopoDS_Edge CERev = CE;
<         CERev.Reverse();
<         RemoveFromMVE (CERev,MVE2);
---
> 	doubleEM.Add( CE );
> 	RemoveFromMVE (CE,MVE2);
> 	TopoDS_Edge CERev = CE;
> 	CERev.Reverse();
> 	RemoveFromMVE (CERev,MVE2);
660,661c583,584
<         // wire is internal if all edges are section ones
<         isInternCW = Standard_False;
---
> 	// wire is internal if all edges are section ones
> 	isInternCW = Standard_False;
664,667c587,590
<         iDeg = MVDEI( CV );
<         TopoDS_Edge NewDegen;
<         NewDegen = MakeDegenAndSelect( CE, CV, NE, SEID[iDeg], SeqU[iDeg], DE[iDeg]);
<         WEL.Append( NewDegen );
---
> 	iDeg = MVDEI( CV );  
> 	TopoDS_Edge NewDegen;
> 	NewDegen = MakeDegenAndSelect( CE, CV, NE, SEID[iDeg], SeqU[iDeg], DE[iDeg]);
> 	WEL.Append( NewDegen );
670c593
<         continue;
---
> 	continue;
677,678c600,601
<         End=Standard_True;
<         MVE.UnBind(CV);
---
> 	End=Standard_True;
> 	MVE.UnBind(CV);
681c604
<         End = Standard_True;
---
> 	End = Standard_True;
684,692c607,615
<         //----------------------------
<         // select new current edge
<         //----------------------------
<         if (! SelectEdge (Surface,CE,CV,NE,MVE(CV))) {
<           MESSAGE ( " NOT CLOSED WIRE " );
<           End=Standard_True;
<         }
<         else
<           CE = NE;
---
> 	//----------------------------
> 	// select new current edge
> 	//----------------------------
> 	if (! SelectEdge (Surface,CE,CV,NE,MVE(CV))) {
> 	  MESSAGE ( " NOT CLOSED WIRE " );
> 	  End=Standard_True;
> 	}
> 	else 
> 	  CE = NE;
694,695c617
<     } // while ( !End )
< 
---
>     } // while ( !End ) 
696a619
>     
699c622
< 
---
>     
704c627
<         B.Add ( NW, itl.Value());
---
> 	B.Add ( NW, itl.Value());
708c631
< 
---
>     
712,716c635,639
<         const TopoDS_Edge& E = TopoDS::Edge ( itl.Value() );
<         if ( doubleEM.Contains( E ) || BRep_Tool::Degenerated( E ))
<           WEL.Remove( itl );
<         else
<            itl.Next();
---
> 	const TopoDS_Edge& E = TopoDS::Edge ( itl.Value() );
> 	if ( doubleEM.Contains( E ) || BRep_Tool::Degenerated( E ))
> 	  WEL.Remove( itl );
> 	else
> 	   itl.Next();
719c642
<         continue;
---
> 	continue;
723,728c646,651
<         for (i=1; i<=SEID[j].Length(); ++i) {
<           if (doubleEM.Contains( SEID[j].Value(i))) {
<             SEID[j].Remove( i );
<             SeqU[j].Remove( i-- );
<           }
<         }
---
> 	for (i=1; i<=SEID[j].Length(); ++i) {
> 	  if (doubleEM.Contains( SEID[j].Value(i))) {
> 	    SEID[j].Remove( i );
> 	    SeqU[j].Remove( i-- );
> 	  }
> 	}
734,742c657,665
<         CE = TopoDS::Edge( WEL.First() );
<         WEL.RemoveFirst();
<         B.MakeWire( NW );
<         VF = TopExp::FirstVertex ( CE, Standard_True);
< 
<         End = Standard_False;
<         while ( !End) {
<           B.Add( NW, CE );
<           CV = TopExp::LastVertex  ( CE, Standard_True);
---
> 	CE = TopoDS::Edge( WEL.First() );
> 	WEL.RemoveFirst();
> 	B.MakeWire( NW );
> 	VF = TopExp::FirstVertex ( EF, Standard_True);
> 	
> 	End = Standard_False;
> 	while ( !End) {
> 	  B.Add( NW, CE );
> 	  CV = TopExp::LastVertex  ( CE, Standard_True);
744,745c667,668
<           if (MVDEI.IsBound( CV )) {   // CE comes to the degeneration
<             iDeg = MVDEI( CV );
---
> 	  if (MVDEI.IsBound( CV )) {   // CE comes to the degeneration
> 	    iDeg = MVDEI( CV );
750,769c673,692
<             CE = NE;
<             if (!NE.IsNull()) { // remove NE from WEL
<               for (itl.Initialize( WEL ); itl.More(); itl.Next())
<                 if ( NE == itl.Value()) {
<                   WEL.Remove( itl );
<                   break;
<                 }
<             }
<           }  // end degeneration
< 
<           else {
<             if (CV.IsSame( VF )) {
<               End = Standard_True;
<               continue;
<             }
<             // edges in WEL most often are well ordered
<             // so try to iterate until the End
<             Standard_Boolean add = Standard_False;
<             itl.Initialize(WEL);
<             while ( itl.More() && !End) {
---
> 	    CE = NE;
> 	    if (!NE.IsNull()) { // remove NE from WEL
> 	      for (itl.Initialize( WEL ); itl.More(); itl.Next())
> 		if ( NE == itl.Value()) {
> 		  WEL.Remove( itl );
> 		  break;
> 		}
> 	    }
> 	  }  // end degeneration
> 	  
> 	  else {
> 	    if (CV.IsSame( VF )) {
> 	      End = Standard_True;
> 	      continue;
> 	    }
> 	    // edges in WEL most often are well ordered
> 	    // so try to iterate until the End
> 	    Standard_Boolean add = Standard_False;
> 	    itl.Initialize(WEL);
> 	    while ( itl.More() && !End) {
773,775c696,698
<                 if (add)
<                   B.Add( NW, CE );
<                 CE = NE;
---
> 		if (add)
> 		  B.Add( NW, CE );
> 		CE = NE;
781,789c704,712
<               else
<                 itl.Next();
<             }
<             if (!add)
<               End = Standard_True;
<           }
<         } // !End
< 
<         myInternalWL.Append( NW );
---
> 	      else
> 		itl.Next();
> 	    }
> 	    if (!add)
> 	      End = Standard_True;
> 	  }
> 	} // !End
> 	
> 	myInternalWL.Append( NW );
794c717
< 
---
>   
796,797c719,720
< 
< 
---
>   
>   
804,807c727,733
<   if (nbIW == 0)
<     return;
< 
<   if ( myNewWires.Extent() != 1 && nbIW > 1) {
---
>   if ( nbIW == 1 ) {
>     TopTools_MapOfShape UsedShapes( 2*NbConstEdges );
>     TopExp_Explorer expV (myInternalWL.First(), TopAbs_VERTEX);
>     if (canPassToOld (expV.Current(), UsedShapes, MVE2, mySectionEdges)) 
>       myNewWires.Append ( myInternalWL );
>   }
>   else if ( nbIW > 1 ) {
811c737
<       if ( ! mySectionEdges.Contains( itl.Value() ))
---
>       if ( ! mySectionEdges.Contains( itl.Value() )) 
834c760
<                                 const TopoDS_Face& F)
---
> 				const TopoDS_Face& F)
840c766
<                                    Precision::PConfusion());
---
> 				   Precision::PConfusion());
850,851c776,777
<                                  const TopoDS_Wire& W1,
<                                  const TopoDS_Wire& W2)
---
> 				 const TopoDS_Wire& W1,
> 				 const TopoDS_Wire& W2)
861,863c787
<   if (BRep_Tool::Degenerated( TopoDS::Edge( exp.Current() )))
<     exp.Next();
<   const TopoDS_Edge& e = TopoDS::Edge(exp.Current());
---
>   const TopoDS_Edge& edg = TopoDS::Edge(exp.Current());
865,866c789,790
<   Handle(Geom2d_Curve) C2d = BRep_Tool::CurveOnSurface(e,F,f,l);
<   gp_Pnt2d pt2d(C2d->Value( 0.5 * ( f + l )));
---
>   Handle(Geom2d_Curve) C2d = BRep_Tool::CurveOnSurface(edg,F,f,l);
>   gp_Pnt2d pt2d(C2d->Value(f));
901,902c825,826
<                        TopTools_DataMapOfShapeShape& EqWM,
<                        const TopoDS_Face& F)
---
> 		       TopTools_DataMapOfShapeShape& EqWM,
> 		       const TopoDS_Face& F)
911c835
< 
---
>     
922,923c846,847
<         if ( !EdgesMap.Contains( itE.Value()) )
<           break;
---
> 	if ( !EdgesMap.Contains( itE.Value()) )
> 	  break;
926,934c850,858
<         if (isHole( Wire1, F)) {
<           EqWM.Bind ( Wire1, Wire2 );
<         }
<         else {
<           EqWM.Bind ( Wire2, Wire1 );
<         }
<         IndMap.Add(i);
<         IndMap.Add(j);
<         break;
---
> 	if (isHole( Wire1, F)) {
> 	  EqWM.Bind ( Wire1, Wire2 );
> 	}
> 	else {
> 	  EqWM.Bind ( Wire2, Wire1 );
> 	}
> 	IndMap.Add(i);
> 	IndMap.Add(j);
> 	break;
956,957c880,881
<                      BRepAlgo_AsDes& OuterInner,
<                      const TopoDS_Face& F)
---
> 		     BRepAlgo_AsDes& OuterInner,
> 		     const TopoDS_Face& F)
962,969c886,887
<     // find next after it1.Value()
<     for (it2.Initialize(EqWM);  it2.More();  it2.Next())
<       if (it1.Value().IsSame( it2.Value() ))
<       {
<         it2.Next();
<         break;
<       }
<     for ( ;  it2.More();  it2.Next()) {
---
>     for (it2.Initialize(EqWM);  it2.More();  it2.Next()) {
>       if (it1.Value().IsSame( it2.Value() )) continue;
973c891
<         OuterInner.Add (Wire2, Wire1);
---
> 	OuterInner.Add (Wire2, Wire1);
975c893
<         OuterInner.Add (Wire1, Wire2);
---
> 	OuterInner.Add (Wire1, Wire2);
986a905,913
> //#define USE_BREPFEAT_SPLITSHAPE
> 
> #ifdef USE_BREPFEAT_SPLITSHAPE
> 
> # include <BRepFeat_SplitShape.hxx>
> void  Partition_Loop2d::WiresToFaces(const BRepAlgo_Image& EdgeImage)
> #else
>      
> # include <BRepAlgo_FaceRestrictor.hxx>
987a915
> #endif
992a921,926
> #ifndef USE_BREPFEAT_SPLITSHAPE
> 
>   // ============================================================
>   // use BRepAlgo_FaceRestrictor to make faces
>   // ============================================================
> 
1001c935
< 
---
>   
1022c956
< 
---
>   
1037c971
< 
---
>     
1049d982
<       Standard_Integer nbEqW = EqWM.Extent(); // protection against infinite loop
1052,1055c985,988
<         TopoDS_Wire outerW = TopoDS::Wire ( it.Value() );
<         if (  OuterInner.HasDescendant( outerW ) && // has internal
<              ! OuterInner.Descendant( outerW ).IsEmpty() )
<           continue;
---
> 	TopoDS_Wire outerW = TopoDS::Wire ( it.Value() );
> 	if (  OuterInner.HasDescendant( outerW ) && // has internal
> 	     ! OuterInner.Descendant( outerW ).IsEmpty() )
> 	  continue;
1057c990
<         FR.Add( outerW );
---
> 	FR.Add( outerW );
1064,1069c997,1002
<             FR.Add (IW);
<             myInternalWL.Remove( itIW ); // == itIW.Next() !!!
<           }
<           else
<             itIW.Next();
<         }
---
> 	    FR.Add (IW);
> 	    myInternalWL.Remove( itIW ); // == itIW.Next() !!!
> 	  }
> 	  else
> 	    itIW.Next();
> 	}
1071,1072c1004,1005
<         // the hole-part of current pair of equal wires will be in the next new face
<         prevHolesL.Append ( it.Key() );
---
> 	// the hole-part of current pair of equal wires will be in the next new face
> 	prevHolesL.Append ( it.Key() );
1079,1080c1012,1013
<         for (; FR.More(); FR.Next())
<           myNewFaces.Append(FR.Current());
---
> 	for (; FR.More(); FR.Next())
> 	  myNewFaces.Append(FR.Current());
1086c1019
<       // remove them from the EqWM,
---
>       // remove themfrom the EqWM,
1091,1116c1024,1040
<         TopoDS_Wire& Hole = TopoDS::Wire ( itPrev.Value() );
<         FR.Add ( Hole );
<         if (clearOuterInner) {
<           const TopoDS_Wire& outerW = TopoDS::Wire ( EqWM.Find( Hole ) );
<           // Loop on wires including outerW
<           TopTools_ListIteratorOfListOfShape itO( OuterInner.Ascendant( outerW ));
<           for (; itO.More(); itO.Next()) {
<             TopTools_ListOfShape& innerL = OuterInner.ChangeDescendant( itO.Value() );
<             TopTools_ListIteratorOfListOfShape itI (innerL);
<             // Loop on internal wires of current including wire
<             for (; itI.More(); itI.Next())
<               if ( outerW.IsSame( itI.Value() )) {
<                 innerL.Remove( itI );   break;
<               }
<           }
<         }
<         EqWM.UnBind ( Hole );
<       }
< 
<       if (nbEqW == EqWM.Extent())
<       {
<         // error: pb with wires classification
< #ifdef DEB
<         cout << "Partition_Loop2d::WiresToFaces(), pb with wires classification" << endl;
< #endif
<         break;
---
> 	TopoDS_Wire& Hole = TopoDS::Wire ( itPrev.Value() );
> 	FR.Add ( Hole );
> 	if (clearOuterInner) {
> 	  const TopoDS_Wire& outerW = TopoDS::Wire ( EqWM.Find( Hole ) );
> 	  // Loop on wires including outerW
> 	  TopTools_ListIteratorOfListOfShape itO( OuterInner.Ascendant( outerW ));
> 	  for (; itO.More(); itO.Next()) {
> 	    TopTools_ListOfShape& innerL = OuterInner.ChangeDescendant( itO.Value() );
> 	    TopTools_ListIteratorOfListOfShape itI (innerL);
> 	    // Loop on internal wires of current including wire
> 	    for (; itI.More(); itI.Next())
> 	      if ( outerW.IsSame( itI.Value() )) {
> 		innerL.Remove( itI );   break;
> 	      }
> 	  }
> 	}
> 	EqWM.UnBind ( Hole );
1121c1045
<   } //  if !EqWM.IsEmpty()
---
>   } //  !EqWM.IsEmpty()
1134a1059,1101
>   
> #else // ifndef USE_BREPFEAT_SPLITSHAPE
> 
>   // ============================================================
>   // use BRepFeat_SplitShape to make faces
>   // ============================================================
>   
>   BRepFeat_SplitShape Split(myFace);
>   TopTools_MapOfShape AddedSectionEdgesMap;
> 
>   myNewWires.Append(myInternalWL);
> 
>   TopTools_ListIteratorOfListOfShape it(myNewWires);
>   for (; it.More(); it.Next()) {
>     TopoDS_Iterator itE(it.Value());
>     for (; itE.More(); itE.Next()) {
>       const TopoDS_Edge& newE = TopoDS::Edge( itE.Value() );
>       if (AddedSectionEdgesMap.Add(newE)) {
> 	if (mySectionEdges.Contains(newE))
>           Split.Add(newE,F); // new edge on face
> 	else {
> 	  const TopoDS_Edge& oldE = TopoDS::Edge( EdgeImage.ImageFrom(newE) );
> 	  Split.Add(newE, oldE); // splited edge
> 	}
>       }
>     }
>   }
>   Split.Build();
> 
>   if (Split.IsDone())
>     myNewFaces = Split.Modified(F);
> 
> #endif  // ifndef USE_BREPFEAT_SPLITSHAPE
> 
> 
>   
> #ifdef DEB
>   Standard_Integer nbF = myNewFaces.Extent();
>   if (nbW != nbF)
>     cout << "WiresToFaces(): " << nbW << " wires --> " << myNewFaces.Extent() << " faces "
>       << endl;
> #endif
> 
1136c1103
<   for (; itNF.More(); itNF.Next())
---
>   for (; itNF.More(); itNF.Next()) 
diff -r ../src/PARTITION/Partition_Loop.cxx ../../../GEOM_SRC/src/PARTITION/Partition_Loop.cxx
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/PARTITION/Partition_Spliter.cdl ../../../GEOM_SRC/src/PARTITION/Partition_Spliter.cdl
97,101d96
<     MakeSolids (me: in out; Solid : Shape from TopoDS;
<                             Shells: in out ListOfShape from TopTools) 
<         is private;
<         ---Purpose: make solids out of Shells
< 
139,153d133
<     IsInside (myclass; S1,S2 : Shape from TopoDS)
<         returns Boolean from Standard is private;
<         ---Purpose: Return True if the first vertex of S1 inside S2.
<         --          If S1.IsNull(), check infinite point against S2.
< 
<     GetOriginalShape(me; aShape : Shape from TopoDS)
<         returns Shape from TopoDS is private;
<         ---Purpose: Return the  shape  aShape  originates from. aShape
<         --          should be a face or more complex result shape
< 
<     FindToolsToReconstruct(me: in out) is private;
<         ---Purpose: find and store  as  objects  tools which interfere
<         --          with  solids   or   are   inside   solids  without
<         --          an interference
< 
156c136
<     myDoneStep     : ShapeEnum           from TopAbs;   -- rebuilt level
---
>     myDoneStep     : ShapeEnum           from TopAbs;   -- reconstructed topology
163,166d142
<     myEqualEdges   : MapOfShape          from TopTools; -- equal splits
<     myNewSection   : MapOfShape          from TopTools; -- new secton edges
<     myClosedShapes : MapOfShape          from TopTools;
<     myWrappingSolid: MapOfShape          from TopTools; -- solids having other shapes inside
169,171c145
<     myInternalFaces: DataMapOfShapeShape from TopTools; -- shape and its internal faces
<     myIntNotClFaces: DataMapOfShapeShape from TopTools; -- internal but not closed 
< 
---
>     myNewSection   : MapOfShape          from TopTools; -- new secton edges
183a158,164
>         -- equal splits
>     myEqualEdges   : MapOfShape          from TopTools;
>     
>         -- shape and its internal faces
>     myInternalFaces: DataMapOfShapeShape from TopTools;
>     myIntNotClFaces: DataMapOfShapeShape from TopTools;-- internal but not closed 
>     
diff -r ../src/PARTITION/Partition_Spliter.cxx ../../../GEOM_SRC/src/PARTITION/Partition_Spliter.cxx
27c27
< //  $Header$
---
> //  $Header$
29a30
> #include "Partition_Spliter.ixx"
34d34
< #include "Partition_Spliter.ixx"
37a38,39
> #include <TopExp_Explorer.hxx>
> #include <TopExp.hxx>
40,41d41
< #include <TopExp.hxx>
< #include <TopExp_Explorer.hxx>
51a52,54
> #include <gp_Pnt2d.hxx>
> #include <gp_Pnt.hxx>
> #include <gp_Vec.hxx>
56,58d58
< #include <gp_Pnt.hxx>
< #include <gp_Pnt2d.hxx>
< #include <gp_Vec.hxx>
70,72d69
< #include <BRepBndLib.hxx>
< #include <BRepClass3d_SolidClassifier.hxx>
< #include <BRepLib.hxx>
73a71,72
> #include <BRepLib.hxx>
> #include <BRepBndLib.hxx>
74a74
> #include <stdio.h>
80c80
< //# define PART_PERF
---
> #define DRAW 0
83,90c83,90
< #ifdef PART_PERF
< # include <OSD_Chronometer.hxx>
< #endif
< 
< //=======================================================================
< //function : isClosed
< //purpose  : check id a shape is closed, ie is a solid or a closed shell
< //=======================================================================
---
> #ifdef DRAW
> #include <DBRep.hxx>
> Standard_IMPORT Standard_Boolean AffichInter3d ;
> Standard_IMPORT Standard_Boolean AffichInter2d ;
> Standard_IMPORT Standard_Boolean AffichVertex;
> Standard_IMPORT Standard_Boolean AffichFace;
> Standard_IMPORT Standard_Boolean AffichWire;
> Standard_IMPORT Standard_Boolean SelectFace;
92,94c92
< static Standard_Boolean isClosed(const TopoDS_Shape& theShape)
< {
<   Standard_Boolean isClosed = (theShape.ShapeType() == TopAbs_SOLID);
---
> static char* names = new char[100];
96,104c94
<   if (!isClosed && theShape.ShapeType() == TopAbs_SHELL) {
<     TopTools_IndexedDataMapOfShapeListOfShape MEF;
<     TopExp::MapShapesAndAncestors(theShape, TopAbs_EDGE, TopAbs_FACE, MEF);
<     for (Standard_Integer i=1;  isClosed && i<=MEF.Extent();  ++i)
<       isClosed = ( MEF(i).Extent() != 1 );
<   }
<   
<   return isClosed;
< }
---
> #endif
124,133d113
<   if (S.ShapeType() < TopAbs_SOLID) { // compound or compsolid
<     TopoDS_Iterator it (S);
<     for (; it.More(); it.Next())
<     {
<       AddTool( it.Value());
<       myFaceShapeMap.Bind( it.Value(), S ); // to know compound by shape
<     }
<     return;
<   }
< 
135d114
<   {
137,140d115
<     myFaceShapeMap.Bind( exp.Current(), S );
<   }
<   if (isClosed( S ))
<     myClosedShapes.Add( S );
153d127
<     {
155,156d128
<       myFaceShapeMap.Bind( it.Value(), S ); // to know compound by shape
<     }
164a137,138
>   
>   myListShapes.Append(S);
166d139
<   Standard_Integer nbFacesBefore = myMapFaces.Extent(); // not to add twice the same S
168,172c141,143
<     const TopoDS_Shape & aFace = exp.Current();
<     if ( ! myFaceShapeMap.IsBound( aFace )) // keep shape of tool face added as object
<       myFaceShapeMap.Bind( aFace, S );
<     if (myMapFaces.Add( aFace ))
<       myImagesFaces.SetRoot( aFace );
---
>     myFaceShapeMap.Bind( exp.Current(), S );
>     myMapFaces.Add(exp.Current());
>     myImagesFaces.SetRoot(exp.Current());
174,186d144
< 
<   if (nbFacesBefore == myMapFaces.Extent())
<     return;
< 
<   // solids must be processed before all
<   if (S.ShapeType() == TopAbs_SOLID)
<     myListShapes.Prepend(S);
<   else
<     myListShapes.Append(S);
< 
<   if (isClosed( S ))
<     myClosedShapes.Add( S );
< 
211,214d168
<   myClosedShapes.Clear();
<   myEqualEdges.Clear();
<   myNewSection.Clear();
<   myWrappingSolid.Clear();
217,218c171
<   myInternalFaces.Clear();
<   myIntNotClFaces.Clear();
---
>   myNewSection.Clear();
228a182
>   myInternalFaces.Clear();
248,251d201
< #ifdef PART_PERF
<   OSD_Chronometer aCron;
< #endif
< 
259,262d208
< #ifdef PART_PERF
<     aCron.Start();
< #endif
< 
268a215
> 
271,275c218,230
< #ifdef PART_PERF
<     cout << "+++ CompletPart3d()" << endl;
<     aCron.Show( cout );
<     aCron.Reset();
<     aCron.Start();
---
>     TopTools_MapOfShape& Modif = myInter3d.TouchedFaces();
>     TopTools_MapOfShape& NewEdges = myInter3d.NewEdges();
>     Handle(BRepAlgo_AsDes) SectionEdgesAD = myInter3d.SectionEdgesAD();
> 
> #ifdef DRAW
>     if (AffichInter3d) {
>       Standard_Integer i=0;
>       for (it.Initialize(NewEdges); it.More(); it.Next(), i++) {
>         sprintf(names,"e_%d",i);
>         cout << "donly " << names << endl;
>         DBRep::Set(names,it.Key());
>       }
>     }
276a232,300
>     //if (Modif.IsEmpty()) return;
> 
>     // -----------------------------------------------
>     // store tools intersecting solids as object shapes,
>     // they must split into faces too
>     // -----------------------------------------------
> 
>     // build edge - face map for tool faces
>     TopTools_IndexedDataMapOfShapeListOfShape EFM;
>     for (it.Initialize(myMapTools); it.More(); it.Next())
>       TopExp::MapShapesAndAncestors( it.Key(), TopAbs_EDGE, TopAbs_FACE, EFM);
> 
>     TopTools_MapOfShape checkedEdgeMap;
>     for (itl.Initialize( myListShapes ); itl.More(); itl.Next()) {
>       TopExp_Explorer expSo (itl.Value(), TopAbs_SOLID);
>       for (; expSo.More(); expSo.Next()) {
> 
>         TopTools_ListOfShape checkFL;  // faces to check
>         for ( exp.Init( expSo.Current(), TopAbs_FACE); exp.More(); exp.Next())
>           checkFL.Append ( exp.Current());
> 
>         // iterate a list while appending new items
>         TopTools_ListIteratorOfListOfShape itF, itCF;
>         for (itCF.Initialize (checkFL) ; itCF.More(); itCF.Next()) {
>           const TopoDS_Shape& F = itCF.Value();
>           if ( myAsDes->HasDescendant( F )) {
>             // new edges on face to check
>             const TopTools_ListOfShape& NEL = myAsDes->Descendant( F );
>             TopTools_ListIteratorOfListOfShape itE (NEL);
>             for (; itE.More(); itE.Next()) {
>               if (checkedEdgeMap.Add( itE.Value() )) {
>                 // intersected faces originating an edge
>                 itF.Initialize (myAsDes->Ascendant( itE.Value() ));
>                 for (; itF.More(); itF.Next()) {
>                   if (!myMapFaces.Contains( itF.Value())) {
>                     AddShape( itF.Value() );
>                     checkFL.Append( itF.Value() );
>                   }
>                 }
>                 // faces having section edges on F
>                 if (EFM.Contains( itE.Value())) 
>                   itF.Initialize ( EFM.FindFromKey (itE.Value()));
>                 for (; itF.More(); itF.Next()) {
>                   if (!myMapFaces.Contains( itF.Value())) {
>                     AddShape( itF.Value() );
>                     checkFL.Append( itF.Value() );
>                   }
>                 }
>               }
>             }
>           }
>           // find faces cut by edges of F
>           TopExp_Explorer expE(F, TopAbs_EDGE);
>           for (; expE.More();expE.Next()) {
>             if ( SectionEdgesAD->HasAscendant( expE.Current() )
>                 && checkedEdgeMap.Add( expE.Current() )) {
>               itF.Initialize( SectionEdgesAD->Ascendant( expE.Current()) );
>               for (; itF.More(); itF.Next()) {
>                 if (!myMapFaces.Contains( itF.Value())) {
>                   AddShape( itF.Value() );
>                   checkFL.Append( itF.Value() );
>                 }
>               }
>             }
>           }
>         }
>       }
>     }
> 
281,290d304
<     // add tool faces which must be reconstructed to myMapFaces too
<     FindToolsToReconstruct();
< 
< #ifdef PART_PERF
<     cout << "+++ FindToolsToReconstruct()" << endl;
<     aCron.Show( cout );
<     aCron.Reset();
<     aCron.Start();
< #endif
< 
310d323
<     TopTools_MapOfShape& Modif = myInter3d.TouchedFaces();
313c326
<       Partition_Inter2d::CompletPart2d (myAsDes, F, myInter3d.NewEdges());
---
>       Partition_Inter2d::CompletPart2d (myAsDes, F, NewEdges);
320,325d332
< #ifdef PART_PERF
<     cout << "+++ CompletPart2d()" << endl;
<     aCron.Show( cout );
<     aCron.Reset();
<     aCron.Start();
< #endif
340d346
< 
344,346c350
<     //-----------------------------------------------
<     // ------- Reconstruction of all the edges.------
<     //-----------------------------------------------
---
>     // Reconstruction of all the edges.
349,351c353,355
<     // ==============
<     // cut new edges
<     // ==============
---
>     // Add to myAsDes end vertices of new edges and cut new edges
>     int j=1;
>     TopTools_MapOfShape& NewEdges = myInter3d.NewEdges();
353c357
<     for ( it.Initialize(myInter3d.NewEdges()); it.More(); it.Next()) {
---
>     for ( it.Initialize(NewEdges); it.More(); it.Next()) {
365,369c369,371
<       // Add end vertices to new edges only if 
<       // one face is Tool and the other is Shape
<       Standard_Boolean isTool1 = ! myMapFaces.Contains( aListF.First() );
<       Standard_Boolean isTool2 = ! myMapFaces.Contains( aListF.Last() );
<       if (isTool1 || isTool2)
---
>       // one face is Tool, the other is Shape:
>       if ( (myMapTools.Contains(aListF.First()) && myMapFaces.Contains(aListF.Last()) ) ||
>           ( myMapFaces.Contains(aListF.First()) && myMapTools.Contains(aListF.Last()) ) )
402a405,413
> #ifdef DRAW
>       if (AffichVertex) {
>         for(itl.Initialize(aListV);itl.More();itl.Next(), j++) {
>           sprintf(names,"v_%d",j);
>           cout << "donly " << names << endl;
>           DBRep::Set(names,itl.Value());
>         }
>       }
> #endif
404d414
<       // cut new edges
406a417
>         // cut new edges
414d424
<     // ==============
416d425
<     // ==============
429,434d437
< #ifdef PART_PERF
<     cout << "+++ Cut Edges" << endl;
<     aCron.Show( cout );
<     aCron.Reset();
<     aCron.Start();
< #endif
436d438
<     // process same domain section edges
441,446d442
< #ifdef PART_PERF
<     cout << "+++ MergeEqualEdges()" << endl;
<     aCron.Show( cout );
<     aCron.Reset();
<     aCron.Start();
< #endif
453,454d448
<       if (myMapTools.Contains( itl.Value() ))
<         continue; // skip tool faces
469a464,466
>   // make faces interfering by section edges share the same splits
>   //ProcessSectionEdges( SectionEdgesAD );
> 
486,491d482
< #ifdef PART_PERF
<     cout << "+++ MakeFaces()" << endl;
<     aCron.Show( cout );
<     aCron.Reset();
<     aCron.Start();
< #endif
508c499
<   // split and add solids and shells
---
>   // split solids
510c501,502
< 
---
>   
>   // solids must remains closed, so process them first
513,517d504
<   for (itl.Initialize(myListShapes);itl.More();itl.Next())
<   {
<     const TopoDS_Shape & S = itl.Value();
<     if (S.ShapeType() > TopAbs_SHELL)
<       continue;
519,531c506,526
<     TopTools_ListOfShape NSL; // new shape list
<     MakeShells (S , NSL);
<     if (makeSolids && S.ShapeType() == TopAbs_SOLID )
<       MakeSolids( S, NSL );
<     
<     TopTools_ListIteratorOfListOfShape itNSL (NSL);
<     for ( ; itNSL.More(); itNSL.Next()) 
<       myBuilder.Add (myShape, itNSL.Value());
<   }
< #ifdef PART_PERF
<     cout << "+++ MakeShells()" << endl;
<     aCron.Show( cout );
< #endif
---
>   for (itl.Initialize(myListShapes);itl.More();itl.Next()) {
>     if (itl.Value().ShapeType() == TopAbs_SOLID) {
>       TopTools_ListOfShape NSL;
>       MakeShells (itl.Value() , NSL);
>       TopTools_ListIteratorOfListOfShape itS(NSL);
>       for ( ; itS.More(); itS.Next()) 
>         if (makeSolids) {
>           // make a solid from a shell
>           TopoDS_Solid Solid;
>           myBuilder.MakeSolid( Solid );
>           myBuilder.Add (Solid, itS.Value());
>           myBuilder.Add (myShape, Solid);
>         }
> 	else 
>           myBuilder.Add (myShape, itS.Value());
>     }
>   }
>       
>   //-----------------------------------------------
>   // split shells
>   //-----------------------------------------------
532a528,537
>   for (itl.Initialize(myListShapes);itl.More();itl.Next()) {
>     if (itl.Value().ShapeType() == TopAbs_SHELL) {
>       TopTools_ListOfShape NSL;
>       MakeShells (itl.Value() , NSL);
>       TopTools_ListIteratorOfListOfShape itS(NSL);
>       for ( ; itS.More(); itS.Next())
> 	myBuilder.Add (myShape, itS.Value());
>     }
>   }
>       
537,539c542,543
<   for (itl.Initialize(myListShapes);itl.More();itl.Next())
<   {
<     const TopoDS_Shape & S = itl.Value();
---
>   for (itl.Initialize(myListShapes);itl.More();itl.Next()) {
>     const TopoDS_Shape& S = itl.Value();
541c545
<         myMapTools.Contains( S ))
---
> 	myMapTools.Contains( S ))
546c550
<         myBuilder.Add (myShape, itS.Value());
---
> 	myBuilder.Add (myShape, itS.Value());
548c552
< 
---
>     
552a557
> 
554,555c559,560
< //function : MakeSolids
< //purpose  : make solids out of Shells
---
> //function : Tri
> //purpose  : 
558,559c563,564
< void Partition_Spliter::MakeSolids(const TopoDS_Shape &   theSolid,
<                                    TopTools_ListOfShape & theShellList)
---
> static void Tri(const TopoDS_Edge&        E,
> 		TopTools_SequenceOfShape& Seq)
561,566c566,569
<   // for a solid wrapping other shells or solids without intersection,
<   // it is necessary to find shells making holes in it
< 
<   TopTools_ListOfShape aNewSolids; // result
<   TopTools_ListOfShape aHoleShells;
<   TopoDS_Shape anInfinitePointShape;
---
>   Standard_Boolean Invert   = Standard_True;
>   Standard_Integer NbPoints = Seq.Length();
>   Standard_Real    U1,U2;
>   TopoDS_Vertex    V1,V2;
568,574c571,593
<   Standard_Boolean isWrapping = myWrappingSolid.Contains( theSolid );
<   if (!isWrapping && !theShellList.IsEmpty())
<   {
<     // check if theSolid initially has internal shells
<     TopoDS_Iterator aShellExp (theSolid);
<     aShellExp.Next();
<     isWrapping = aShellExp.More();
---
>   while (Invert) {
>     Invert = Standard_False;
>     for ( Standard_Integer i = 1; i < Seq.Length(); i++) {
>       
>       V1 = TopoDS::Vertex(Seq.Value(i));
>       V2 = TopoDS::Vertex(Seq.Value(i+1));
>       
>       V1.Orientation(TopAbs_INTERNAL);
>       V2.Orientation(TopAbs_INTERNAL);
>       
>       U1 = BRep_Tool::Parameter(V1,E);
>       U2 = BRep_Tool::Parameter(V2,E);
>       
>       if (IsEqual(U1,U2)) {
> 	Seq.Remove(i);
> 	i--;
> 	continue;
>       }
>       if (U2 < U1) {
> 	Seq.Exchange(i,i+1);
> 	Invert = Standard_True;
>       }
>     }
576,580c595
<   
<   TopTools_ListIteratorOfListOfShape aShellIt(theShellList);
<   for ( ; aShellIt.More(); aShellIt.Next())
<   {
<     const TopoDS_Shape & aShell = aShellIt.Value();
---
> }
582,590c597,616
<     // check if a shell is a hole
<     if (isWrapping && IsInside (anInfinitePointShape, aShell))
<       aHoleShells.Append( aShell );
<     else
<     {
<       // make a solid from a shell
<       TopoDS_Solid Solid;
<       myBuilder.MakeSolid( Solid );
<       myBuilder.Add (Solid, aShell);
---
> //=======================================================================
> //function : MakeEdges
> //purpose  : cut E by vertices VOnE, return list of new edges NE
> //=======================================================================
> 
> void Partition_Spliter::MakeEdges (const TopoDS_Edge& E,
>                                    const TopTools_ListOfShape& VOnE,
>                                    TopTools_ListOfShape& NE   ) const
> {
>   TopoDS_Edge WE = E;
>   WE.Orientation(TopAbs_FORWARD);
> 
>   TopTools_ListIteratorOfListOfShape itv(VOnE);
>   TopTools_SequenceOfShape SV;
> 
>   Standard_Real    U1,U2, f, l;
>   TopoDS_Vertex    V1,V2,VF,VL;
> 
>   BRep_Tool::Range(WE,f,l);
>   TopExp::Vertices(WE,VF,VL);
592c618,622
<       aNewSolids.Append (Solid);
---
>   if (VOnE.Extent() < 3) { // do not rebuild not cut edge
>     if (( VF.IsSame( VOnE.First() ) && VL.IsSame( VOnE.Last() )) ||
> 	VL.IsSame( VOnE.First() ) && VF.IsSame( VOnE.Last() )  ) {
>       NE.Append( E );
>       return;
596,606c626,627
<   // find outer a shell most close to each hole shell
<   TopTools_DataMapOfShapeShape aInOutMap;
<   for (aShellIt.Initialize( aHoleShells ); aShellIt.More(); aShellIt.Next())
<   {
<     const TopoDS_Shape & aHole = aShellIt.Value();
<     TopTools_ListIteratorOfListOfShape aSolisIt (aNewSolids);
<     for ( ; aSolisIt.More(); aSolisIt.Next())
<     {
<       const TopoDS_Shape & aSolid = aSolisIt.Value();
<       if (! IsInside( aHole, aSolid ))
<         continue;
---
>   for (; itv.More(); itv.Next()) 
>     SV.Append(itv.Value());
608,616c629,648
<       if ( aInOutMap.IsBound (aHole))
<       {
<         const TopoDS_Shape & aSolid2 = aInOutMap( aHole );
<         if ( IsInside( aSolid, aSolid2 ))
<         {
<           aInOutMap.UnBind( aHole );
<           aInOutMap.Bind ( aHole, aSolid );
<         }
<       }
---
>   Tri( WE, SV);
> 
>   Standard_Integer iVer, NbVer = SV.Length();
> 
> 
>   //----------------------------------------------------------------
>   // Construction of the new edges .
>   //----------------------------------------------------------------
> 
>   if (VF.IsSame(VL)) { // closed edge
>     if (NbVer==1) 
>       SV.Append( SV.First() );
>     else if (!SV.First().IsSame(SV.Last())) {
>       Standard_Boolean isFirst=0;
>       Standard_Real    minDU = 1.e10;
>       TopoDS_Vertex endV = Partition_Inter2d::FindEndVertex(VOnE, f,l, E, isFirst,minDU);
>       if (endV.IsSame(SV.First()))
> 	SV.Append(endV);
>       else if (endV.IsSame(SV.Last()))
> 	SV.Prepend(endV);
618c650
<         aInOutMap.Bind ( aHole, aSolid );
---
> 	MESSAGE ("END VERTEX IS IN SEQUNCE MIDDLE");
620,623c652
< 
<     // add aHole to a solid
<     if (aInOutMap.IsBound( aHole ))
<       myBuilder.Add ( aInOutMap( aHole ), aHole );
---
>     NbVer = SV.Length();
626,627c655,693
<   theShellList.Clear();
<   theShellList.Append( aNewSolids );
---
>   for (iVer=1; iVer < NbVer; iVer++) {
>     V1  = TopoDS::Vertex(SV(iVer));
>     V2  = TopoDS::Vertex(SV(iVer+1));
>     
>     TopoDS_Shape NewEdge = WE.EmptyCopied();
>     V1.Orientation(TopAbs_FORWARD);
>     myBuilder.Add  (NewEdge,V1);
>     V2.Orientation(TopAbs_REVERSED);
>     myBuilder.Add  (NewEdge,V2);
>     
>     if (iVer==1)
>       U1 = f;
>     else 	{
>       V1.Orientation(TopAbs_INTERNAL);
>       U1=BRep_Tool::Parameter(V1,WE);
>     }
>     if (iVer+1 == NbVer)
>       U2 = l;
>     else	{
>       V2.Orientation(TopAbs_INTERNAL);
>       U2=BRep_Tool::Parameter(V2,WE);
>     }
>     if (Abs(U1-U2) <= Precision::PConfusion()) {
>       MESSAGE( "MakeEdges(), EQUAL PARAMETERS OF DIFFERENT VERTICES");
>       continue;
>     }
>     TopoDS_Edge EE=TopoDS::Edge(NewEdge);
>     myBuilder.Range (EE,U1,U2);
> 
>     TopoDS_Edge NEdge = TopoDS::Edge(NewEdge);
>     myBuilder.SameParameter(NEdge,Standard_False);
> 
>     Standard_Real tol = 1.0e-2;
>     Standard_Boolean flag = BRep_Tool::SameParameter(NEdge);
>     if (!flag) {
>       BRepLib::SameParameter(NEdge,tol);
>     }
>     NE.Append(NEdge.Oriented(E.Orientation()));
>   }
629c695
<  
---
> 
644,646d709
<   // ================================================
<   // check if internal faces have been already found
<   // ================================================
668,671d730
<   // ===================================
<   // get data for internal faces search
<   // ===================================
< 
682c741
<     const TopoDS_Shape & resE = expl.Current() ;
---
>     TopoDS_Shape resE = expl.Current() ;
718,737d776
<   // add tool faces having section edges on faces of theShape to MFP and DMSEFP;
<   // such tool faces need not to be reconstructed and so they are not in myListShapes
<   for (itm.Initialize(myMapTools); itm.More(); itm.Next())
<   {
<     const TopoDS_Shape & aToolFace = itm.Key();
<     if (myMapFaces.Contains( aToolFace ))
<       continue;
<     MFP.Add(aToolFace);
<     for (expl.Init( aToolFace, TopAbs_EDGE ); expl.More(); expl.Next()) {
<       TopoDS_Shape se = expl.Current();
<       if ( MSE.Contains( se )) {// section edge
<         if (!DMSEFP.IsBound( se )) 
<           DMSEFP.Bind( se, EmptyL );
<         DMSEFP( se ).Append( aToolFace );
<       }
<     }
<   }
<   
< 
<   // ===========================
739d777
<   // ===========================
754c792
<     // does OrigE itself splits a face
---
>     // is OrigE itself splits a face
778,780c816
<       TopoDS_Shape anOrigFace = aFace1;
<       if (myImagesFaces.IsImage(aFace1))
<         anOrigFace = myImagesFaces.Root(aFace1);
---
>       const TopoDS_Shape& anOrigFace = myImagesFaces.Root(aFace1);
830c866
<       //face of CSF sharing E
---
>        //face of CSF sharing E
835,843d870
<       if (inside && isSectionE)
<       {
<         // aFace1 must be tested with both adjacent faces of CSF
<         const TopoDS_Shape& aShapeFace2 = sameDom1 ? FL.First() : FL.Last();
<         if (aShapeFace2 != aShapeFace)
<           inside = Partition_Loop3d::IsInside (E, TopoDS::Face(aShapeFace2), aFace1,
<                                                1, dot, GoodOri);
<       }
< 
846,847c873
<         KeepFaces.Append(aFace1);
< 
---
> 	KeepFaces.Append(aFace1);
858c884
<           KeepFaces.Append(aFace2);
---
> 	  KeepFaces.Append(aFace2);
863d888
<   // ===================================================
865d889
<   // ===================================================
906,911c930
<   // ===============================================================
<   // here MFP contains faces outer of theShape and those of shapes
<   // which do not interfere with theShape at all and between which
<   // there may be those wrapped by theShape and whose faces may be
<   // needed to be returned as well
<   // ===============================================================
---
>   // check if kept faces form a shell without free edges
913,976c932,936
<   Standard_Boolean isSolid = (theShape.ShapeType() == TopAbs_SOLID);
<   if (All || isSolid)  // All is for sub-result removal
<   {
<     for ( itm.Initialize( MFP ); itm.More(); itm.Next() ) {
<       TopoDS_Shape aFace = itm.Key();
< 
<       // find a shape aFace originates from
<       TopoDS_Shape anOrigShape = GetOriginalShape( aFace );
< 
<       // find out if all faces of anOrigShape are not in MFP
<       // and by the way remove them from MFP
<       Standard_Boolean isAllOut = Standard_True;
<       TopoDS_Shape aSplitFaces = anOrigShape;
<       if (myImageShape.HasImage(anOrigShape))
<         aSplitFaces = myImageShape.Image(anOrigShape).First();
< 
<       TopTools_ListOfShape aSplitFaceL;
<       for (expl.Init( aSplitFaces, TopAbs_FACE ); expl.More(); expl.Next())
<       {
<         const TopoDS_Shape & aSpFace = expl.Current();
<         // a tool face which become object has image but the whole tool shape has not
<         if (myImageShape.HasImage( aSpFace ))
<         {
<           TopExp_Explorer exF (myImageShape.Image( aSpFace ).First(), TopAbs_FACE );
<           for ( ; exF.More(); exF.Next() )
<           {
<             aSplitFaceL.Append( exF.Current() );
<             if ( ! MFP.Remove( exF.Current() ))
<               isAllOut = Standard_False;
<           }
<         }
<         else
<         {
<           aSplitFaceL.Append( aSpFace );
<           if ( ! MFP.Remove( aSpFace ))
<             isAllOut = Standard_False;
<         }
<       }
<       itm.Initialize( MFP );
<       if ( !isAllOut )
<         continue;
< 
<       // classify anOrigShape against theShape
<       if (IsInside (anOrigShape, theShape))
<       {
<         if (isSolid && myClosedShapes.Contains( anOrigShape ))
<           // to make a special care at solid reconstruction
<           myWrappingSolid.Add ( theShape );
< 
<         // keep faces of an internal shape anOrigShape
<         KeptFaces.Append( aSplitFaceL );
<       }
<     }
<   }
< 
<   // ====================================================
<   // check if kept faces form a shell without free edges
<   // ====================================================
< 
<   DMEF.Clear();  // edge - kept faces
<   MFP.Clear(); // reuse it for wrong faces
<   if (CheckClosed) {
<     for (itl.Initialize(KeptFaces); itl.More(); itl.Next() ) 
<       TopExp::MapShapesAndAncestors(itl.Value(), TopAbs_EDGE, TopAbs_FACE, DMEF);
---
>   DMEF.Clear();  // edge - kept faces
>   MFP.Clear(); // wrong faces
>   if (CheckClosed) {
>     for (itl.Initialize(KeptFaces); itl.More(); itl.Next() ) 
>       TopExp::MapShapesAndAncestors(itl.Value(), TopAbs_EDGE, TopAbs_FACE, DMEF);
984,985c944
<         if (! BRep_Tool::Degenerated( TopoDS::Edge( E )) &&
<             ! MSE.Contains( E ))
---
>         if (! MSE.Contains( E ))
1006,1009c965
<   // ==============
<   // make a result
<   // ==============
< 
---
>   // a result compound
1043a1000,1009
>   // check if S is closed shape
>   Standard_Boolean isClosed = Standard_True;
> 
>   TopTools_IndexedDataMapOfShapeListOfShape MEF;
>   Standard_Integer i;
>   if (S.ShapeType() != TopAbs_SOLID) {
>     TopExp::MapShapesAndAncestors(S, TopAbs_EDGE, TopAbs_FACE, MEF);
>     for (i=1;  isClosed && i<=MEF.Extent();  ++i) 
>       isClosed = ( MEF(i).Extent() != 1 );
>   }
1048,1049c1014,1015
<   // add split faces inside S
<   if (myClosedShapes.Contains( S )) {
---
>   // split faces inside S
>   if (isClosed) {
1051a1018,1019
> // } else { // a shell may become closed
> //     ShellMaker.AddConstFaces( InternalFacesComp );
1056c1024
<   // Add faces added to new shell to myAddedFacesMap:
---
>   // 1. Add faces added to new shell to myAddedFacesMap:
1057a1026
>   // 2. Check shell closeness (DEBUG)
1059a1029,1031
> #ifdef DEB
>     Standard_Boolean checkCloseness = Standard_True;
> #endif
1061c1033,1034
<     for (; expF.More(); expF.Next())
---
>     for (; expF.More(); expF.Next()) {
>       
1062a1036,1042
>       
> #ifdef DEB
>       if (checkCloseness &&
> 	  ! myInter3d.HasSameDomainF( myImagesFaces.Root(expF.Current()) ))
> 	checkCloseness = Standard_False;
> #endif
>     }
1063a1044,1061
> #ifdef DEB
>     if (checkCloseness) {
>       // if S is closed, a new shell must be closed too;
>       if (isClosed) {
> 	// check that a new shell is closed
> 	MEF.Clear();
> 	TopExp::MapShapesAndAncestors(itS.Value(), TopAbs_EDGE, TopAbs_FACE, MEF);
> 	for (i=1;  isClosed && i<=MEF.Extent();  ++i) 
> 	  isClosed = ( MEF(i).Extent() != 1 );
> 	if (!isClosed) { // remove not closed shell
> 	  MESSAGE (" NOT CLOSED SHELL " );
> 	  //NS.Remove( itS );
> 	  itS.Next();
> 	  continue;
> 	}
>       }
>     }
> #endif
1065c1063
<   }
---
>   } // loop on new shells
1070,1072c1068,1070
< //purpose  : compare edges of EL1 against edges of EL2,
< //           Result is in EMM binding EL1 edges to list of equal edges.
< //           Edges are considered equall only if they have same vertices.
---
> //purpose  : compare edges form EL1 against edges from EL2,
> //           Result is in EMM binding edge form EL1 to list of equal edges
> //           Edges are considered equall only if they have same vertices
1116c1114
<       if (BRep_Tool::Degenerated( E2 ) || AllEqMap.Contains (E2))
---
>       if (BRep_Tool::Degenerated( E2 ))
1212c1210
<       TopTools_MapOfShape AddedEqualM, EqualSeamM;
---
>       TopTools_MapOfShape AddedEqualM;
1235,1239c1233,1234
< 	    if (AddedEqualM.Contains( NE )) {
<               // a seam must be twice in a loop
<               if (!BRep_Tool::IsClosed( E, F ) || !EqualSeamM.Add( NE ))
<                 continue;
<             }
---
> 	    if (AddedEqualM.Contains( NE ))
> 	      continue;
1274,1275c1269,1270
< 	    if (myEqualEdges.Contains( NE ))
<               AddedEqualM.Add( NE );
---
> 	    if (myEqualEdges.Contains( NE ) && !AddedEqualM.Add( NE ))
> 	      continue;
1378,1528d1372
< 
< //=======================================================================
< //function : Tri
< //purpose  : 
< //=======================================================================
< 
< static void Tri(const TopoDS_Edge&        E,
< 		TopTools_SequenceOfShape& Seq,
<                 const Partition_Inter3d & theInter3d)
< {
<   Standard_Boolean Invert   = Standard_True;
<   Standard_Real    U1,U2;
<   TopoDS_Vertex    V1,V2;
< 
<   while (Invert) {
<     Invert = Standard_False;
<     for ( Standard_Integer i = 1; i < Seq.Length(); i++) {
<       
<       V1 = TopoDS::Vertex(Seq.Value(i));
<       V2 = TopoDS::Vertex(Seq.Value(i+1));
<       
<       V1.Orientation(TopAbs_INTERNAL);
<       V2.Orientation(TopAbs_INTERNAL);
<       
<       U1 = BRep_Tool::Parameter(V1,E);
<       U2 = BRep_Tool::Parameter(V2,E);
<       
<       if (IsEqual(U1,U2)) {
<         if (theInter3d.ReplaceSameDomainV( V1, E ).IsSame( V1 ))
<           Seq.Remove(i+1); // remove V2
<         else
<           Seq.Remove(i);
< 	i--;
< 	continue;
<       }
<       if (U2 < U1) {
< 	Seq.Exchange(i,i+1);
< 	Invert = Standard_True;
<       }
<     }
<   }
< }
< 
< //=======================================================================
< //function : MakeEdges
< //purpose  : cut E by vertices VOnE, return list of new edges NE
< //=======================================================================
< 
< void Partition_Spliter::MakeEdges (const TopoDS_Edge& E,
<                                    const TopTools_ListOfShape& VOnE,
<                                    TopTools_ListOfShape& NE   ) const
< {
<   TopoDS_Edge WE = E;
<   WE.Orientation(TopAbs_FORWARD);
< 
<   Standard_Real    U1,U2, f, l;
<   TopoDS_Vertex    V1,V2,VF,VL;
< 
<   BRep_Tool::Range(WE,f,l);
<   TopExp::Vertices(WE,VF,VL);
< 
<   if (VOnE.Extent() < 3) { // do not rebuild not cut edge
<     if (( VF.IsSame( VOnE.First() ) && VL.IsSame( VOnE.Last() )) ||
< 	VL.IsSame( VOnE.First() ) && VF.IsSame( VOnE.Last() )  ) {
<       NE.Append( E );
<       return;
<     }
<   }
< 
<   TopTools_SequenceOfShape SV;
<   TopTools_ListIteratorOfListOfShape itv(VOnE);
<   TopTools_MapOfOrientedShape VM( VOnE.Extent() );
<   for (; itv.More(); itv.Next())
<     if ( VM.Add( itv.Value() ))
<       SV.Append(itv.Value());
< 
<   Tri( WE, SV, myInter3d );
< 
<   if (SV.Length() < 3) { // do not rebuild not cut edge
<     if (( VF.IsSame( SV.First() ) && VL.IsSame( SV.Last() )) ||
< 	VL.IsSame( SV.First() ) && VF.IsSame( SV.Last() )  ) {
<       NE.Append( E );
<       return;
<     }
<   }
< 
<   Standard_Integer iVer, NbVer = SV.Length();
< 
< 
<   //----------------------------------------------------------------
<   // Construction of the new edges .
<   //----------------------------------------------------------------
< 
<   if (VF.IsSame(VL)) { // closed edge
<     if (NbVer==1) 
<       SV.Append( SV.First() );
<     else if (!SV.First().IsSame(SV.Last())) {
<       Standard_Boolean isFirst=0;
<       Standard_Real    minDU = 1.e10;
<       TopoDS_Vertex endV = Partition_Inter2d::FindEndVertex(VOnE, f,l, E, isFirst,minDU);
<       if (endV.IsSame(SV.First()))
< 	SV.Append(endV);
<       else if (endV.IsSame(SV.Last()))
< 	SV.Prepend(endV);
<       else
< 	MESSAGE ("END VERTEX IS IN SEQUNCE MIDDLE");
<     }
<     NbVer = SV.Length();
<   }
< 
<   for (iVer=1; iVer < NbVer; iVer++) {
<     V1  = TopoDS::Vertex(SV(iVer));
<     V2  = TopoDS::Vertex(SV(iVer+1));
<     
<     TopoDS_Shape NewEdge = WE.EmptyCopied();
<     V1.Orientation(TopAbs_FORWARD);
<     myBuilder.Add  (NewEdge,V1);
<     V2.Orientation(TopAbs_REVERSED);
<     myBuilder.Add  (NewEdge,V2);
<     
<     if (iVer==1)
<       U1 = f;
<     else 	{
<       V1.Orientation(TopAbs_INTERNAL);
<       U1=BRep_Tool::Parameter(V1,WE);
<     }
<     if (iVer+1 == NbVer)
<       U2 = l;
<     else	{
<       V2.Orientation(TopAbs_INTERNAL);
<       U2=BRep_Tool::Parameter(V2,WE);
<     }
<     if (Abs(U1-U2) <= Precision::PConfusion()) {
<       MESSAGE( "MakeEdges(), EQUAL PARAMETERS OF DIFFERENT VERTICES");
<       continue;
<     }
<     TopoDS_Edge EE=TopoDS::Edge(NewEdge);
<     myBuilder.Range (EE,U1,U2);
< 
<     TopoDS_Edge NEdge = TopoDS::Edge(NewEdge);
<     myBuilder.SameParameter(NEdge,Standard_False);
< 
<     Standard_Real tol = 1.0e-2;
<     Standard_Boolean flag = BRep_Tool::SameParameter(NEdge);
<     if (!flag) {
<       BRepLib::SameParameter(NEdge,tol);
<     }
<     NE.Append(NEdge.Oriented(E.Orientation()));
<   }
< }
< 
1547d1390
< 
1558d1400
<     // update edge images and build pcurves
1564,1565d1405
< 
<       // 1. build pcurves of the kept edge on faces where replaced edges exist
1568,1577c1408,1412
<       FL = myAsDes->Ascendant( EReplOrig );
<       Standard_Integer iFace, iFirstSectionFace = FL.Extent() + 1;
<       // add faces where the replaced edge is a section edge
<       if (myInter3d.IsSectionEdge( EReplOrig )) {
<         TopTools_ListIteratorOfListOfShape seIt;
<         seIt.Initialize( myInter3d.SectionEdgeFaces ( EReplOrig ));
<         for ( ; seIt.More(); seIt.Next())
<           FL.Append( seIt.Value() );
<       }
<       // loop on faces
---
>       if (myInter3d.IsSectionEdge( EReplOrig ))
> 	FL = myInter3d.SectionEdgeFaces ( EReplOrig );
>       else
> 	FL = myAsDes->Ascendant( EReplOrig );
> 	
1579c1414
<       for ( iFace = 1 ; itF.More(); itF.Next(), ++iFace ) {
---
>       for ( ; itF.More(); itF.Next()) {
1581c1416
< 
---
>         // build pcurves
1592,1641c1427,1432
< 
<         if (iFace >= iFirstSectionFace ||
<             !BRep_Tool::IsClosed( EReplOrig, F ))
<           continue;
< 
<         // build the second pcurve for a seam
<         TopoDS_Vertex V = TopExp::FirstVertex( EKeep );
<         Standard_Real Ukeep = BRep_Tool::Parameter( V, EKeep );
<         Standard_Real Urepl = BRep_Tool::Parameter( V, E );
< 
<         TopoDS_Edge EReplRev = E;
<         EReplRev.Reverse();
<         Handle(Geom2d_Curve) pcRepl1 = BRep_Tool::CurveOnSurface( E, F, f,l);
<         Handle(Geom2d_Curve) pcRepl2 = BRep_Tool::CurveOnSurface( EReplRev, F, f,l);
< 
<         gp_Pnt2d p1r, p2r, pk;
<         p1r = pcRepl1->Value( Urepl );
<         p2r = pcRepl2->Value( Urepl );
<         pk  = pc->Value( Ukeep );
< 
<         // suppose that pk is equal to either p1r or p2r
<         Standard_Boolean isUPeriod =
<           ( Abs( p1r.X() - p2r.X() ) > Abs( p1r.Y() - p2r.Y() ));
<         Standard_Boolean is1Equal;
<         if (isUPeriod)
<           is1Equal = ( Abs( p1r.X() - pk.X() ) < Abs( p2r.X() - pk.X() ));
<         else
<           is1Equal = ( Abs( p1r.Y() - pk.Y() ) < Abs( p2r.Y() - pk.Y() ));
< 
<         Handle(Geom2d_Curve) pc2 = Handle(Geom2d_Curve)::DownCast
<           ( pc->Translated( pk, is1Equal ? p2r : p1r ) );
< 
<         if (E.Orientation() == TopAbs_REVERSED)
<           is1Equal = !is1Equal;
< 
<         if (is1Equal)
<           myBuilder.UpdateEdge( EKeep, pc, pc2, F, tol);
<         else
<           myBuilder.UpdateEdge( EKeep, pc2, pc, F, tol);
< 
<       } // loop on a Faces where a replaced edge exists
< 
< 
<       // 2. update edge images according to replacement
<       if (myImagesEdges.HasImage( E ))
<         myImagesEdges.Remove( E );
<       myImagesEdges.Bind( E, EKeep );
< 
<     } // loop on a list of equal edges EEL
<   } // loop on a map of equal edges EEM
---
>       }
>       // replace edges in faces
>       if (!myImagesEdges.HasImage( E ))
> 	myImagesEdges.Bind( E, EKeep );
>     }
>   }
1666,1667c1457,1464
<   TopoDS_Shape IntFacesComp = FindFacesInside( S, Standard_False, Standard_True);
<   TopExp::MapShapes( IntFacesComp, TopAbs_FACE, MIF );
---
> 
>   // if S is not a tool, make sure that split faces of S are in MIF
>   if (!isTool)
>     TopExp::MapShapes( myImageShape.Image(S).First(), TopAbs_FACE, MIF);
> 
>   TopoDS_Shape InsFacesComp = FindFacesInside( S, Standard_False, Standard_True);
>   TopExp::MapShapes( InsFacesComp, TopAbs_FACE, MIF );
> 
1672,1696c1469,1470
<   TopAbs_ShapeEnum anInternalShapeType = TopAbs_SHAPE;
<   if (!MIF.IsEmpty())
<   {
<     // leave in the result only those shapes having a face in MIF
<     for (it.Initialize( myShape ); it.More(); it.Next()) {
<       const TopoDS_Shape & aResShape = it.Value();
<       TopExp_Explorer expResF( aResShape, TopAbs_FACE );
<       for (; expResF.More(); expResF.Next()) {
<         if ( MIF.Contains( expResF.Current())) {
<           myBuilder.Add( C, aResShape );
<           if (aResShape.ShapeType() < anInternalShapeType)
<             anInternalShapeType = aResShape.ShapeType();
<           break;
<         }
<       }
<     }
<   }
< 
<   // may be S was not split by internal faces then it is missing
<   // in myShape, add it
<   if (!isTool &&
<       (anInternalShapeType > TopAbs_SOLID || S.ShapeType() > TopAbs_SOLID))
<   {
<     TopTools_IndexedMapOfShape MSF; // map of split faces of S
<     TopExp::MapShapes( myImageShape.Image(S).First(), TopAbs_FACE, MSF);
---
>   // leave in the result only those shapes having a face in MIF
>   for (it.Initialize( myShape ); it.More(); it.Next()) {
1698,1705c1472,1474
<     // find a shape having all faces in MSF
<     for (it.Initialize( myShape ); it.More(); it.Next()) {
<       TopExp_Explorer expResF( it.Value(), TopAbs_FACE );
<       for (; expResF.More(); expResF.Next()) {
<         if (! MSF.Contains( expResF.Current())) 
<           break;
<       }
<       if (! expResF.More()) {
---
>     TopExp_Explorer expResF( it.Value(), TopAbs_FACE );
>     for (; expResF.More(); expResF.Next()) {
>       if ( MIF.Contains( expResF.Current())) {
1734c1503
<   TopoDS_Shape IntFacesComp = FindFacesInside( S, Standard_False, Standard_True);
---
>   TopoDS_Shape InsFacesComp = FindFacesInside( S, Standard_False, Standard_True);
1736c1505
<   TopExp::MapShapes( IntFacesComp, TopAbs_FACE, MIF);
---
>   TopExp::MapShapes( InsFacesComp, TopAbs_FACE, MIF);
1871,1875c1640
<     {
<       // F intersects nothing
<       myBuilder.Add( C, F );
<       continue;
<     }
---
>       continue; // F intersects nothing
1921,2145d1685
< 
< //=======================================================================
< //function : IsInside
< //purpose  : Return True if the first vertex of S1 inside S2.
< //           If S1.IsNull(), check infinite point against S2.
< //=======================================================================
< 
< Standard_Boolean Partition_Spliter::IsInside (const TopoDS_Shape& theS1,
<                                               const TopoDS_Shape& theS2)
< {
<   BRepClass3d_SolidClassifier aClassifier( theS2 );
< 
<   TopExp_Explorer expl( theS1, TopAbs_VERTEX );
<   if (!expl.More())
<     aClassifier.PerformInfinitePoint( ::RealSmall());
<   else
<   {
<     const TopoDS_Vertex & aVertex = TopoDS::Vertex( expl.Current() );
<     aClassifier.Perform (BRep_Tool::Pnt( aVertex ),
<                          BRep_Tool::Tolerance( aVertex ));
<   }
< 
<   return ( aClassifier.State() == TopAbs_IN );
< }
< 
< //=======================================================================
< //function : GetOriginalShape
< //purpose  : Return the  shape  aShape  originates from. aShape
< //           should be a face or more complex result shape
< //=======================================================================
< 
< TopoDS_Shape Partition_Spliter::GetOriginalShape(const TopoDS_Shape& theShape) const
< {
<   TopoDS_Shape anOrigShape;
< 
<   TopExp_Explorer expl( theShape, TopAbs_FACE);
<   if (expl.More())
<   {
< 
<     TopoDS_Shape aFace = expl.Current();
<     if (myImagesFaces.IsImage( aFace ))
<       aFace = myImagesFaces.Root( aFace );
<     anOrigShape = myFaceShapeMap.Find( aFace );
<   }
<   return anOrigShape;
< }
< 
< //=======================================================================
< //function : FindToolsToReconstruct
< //purpose  : find and store  as  objects  tools which interfere
< //           with  solids   or   are   inside   solids  without
< //           an interference
< //=======================================================================
< 
< void Partition_Spliter::FindToolsToReconstruct()
< {
<   if (myMapTools.IsEmpty())
<     return;
< 
<   Standard_Integer nbFoundTools = 0;
< 
<   // build edge - face map in order to detect interference with section edges
<   TopTools_IndexedDataMapOfShapeListOfShape EFM;
<   TopTools_MapIteratorOfMapOfShape aMapIt;
<   for (aMapIt.Initialize(myMapTools); aMapIt.More(); aMapIt.Next())
<     TopExp::MapShapesAndAncestors( aMapIt.Key(), TopAbs_EDGE, TopAbs_FACE, EFM);
<   for (aMapIt.Initialize(myMapFaces); aMapIt.More(); aMapIt.Next())
<     TopExp::MapShapesAndAncestors( aMapIt.Key(), TopAbs_EDGE, TopAbs_FACE, EFM);
< 
<   TopTools_MapOfShape aCurrentSolids, aCheckedShapes;
< 
<   // faces cut by new edges
<   TopTools_MapOfShape & aSectionFaces = myInter3d.TouchedFaces();
< 
<   // keep solids interfering with each other in aCurrentSolids map
<   // and add tool faces intersecting solids as object shapes
< 
<   TopTools_ListIteratorOfListOfShape itS, itF, itCF, itE;
<   for (itS.Initialize( myListShapes ); itS.More(); itS.Next()) {
<     TopExp_Explorer expSo (itS.Value(), TopAbs_SOLID);
<     for (; expSo.More(); expSo.Next()) {
< 
<       // check if a solid has been already processed
<       const TopoDS_Shape & aSo = expSo.Current();
<       if (!aCheckedShapes.Add( aSo ))
<         continue;
<       aCurrentSolids.Add( aSo );
< 
<       // faces to check
<       TopTools_ListOfShape aFacesToCheck;
<       TopExp_Explorer exp( aSo, TopAbs_FACE );
<       for ( ; exp.More(); exp.Next())
<         aFacesToCheck.Append ( exp.Current());
< 
<       // add other shapes interefering with a solid.
<       // iterate faces to check while appending new ones
<       for (itCF.Initialize (aFacesToCheck) ; itCF.More(); itCF.Next())
<       {
<         const TopoDS_Shape& aCheckFace = itCF.Value();
< //         if (!aCheckedShapes.Add( aCheckFace ))
< //           continue;
< 
<         // find faces interfering with aCheckFace
<         TopTools_ListOfShape anIntFaces;
< 
<         // ** 1. faces intersecting aCheckFace with creation of new edges on it
<         if ( myAsDes->HasDescendant( aCheckFace ))
<         {
<           // new edges on aCheckFace
<           const TopTools_ListOfShape& NEL = myAsDes->Descendant( aCheckFace );
<           for (itE.Initialize( NEL); itE.More(); itE.Next())
<           {
<             const TopoDS_Shape & aNewEdge = itE.Value();
<             if (!aCheckedShapes.Add( aNewEdge ))
<               continue;
< 
<             // faces interfering by aNewEdge
<             itF.Initialize (myAsDes->Ascendant( aNewEdge ));
<             for (; itF.More(); itF.Next())
<               if (aCheckFace != itF.Value())
<                 anIntFaces.Append( itF.Value() );
< 
<             // ** 2. faces having section edge aNewEdge on aFacesToCheck
<             if (EFM.Contains( aNewEdge))
<             {
<               itF.Initialize ( EFM.FindFromKey (itE.Value()));
<               for (; itF.More(); itF.Next())
<                 if (aCheckFace != itF.Value())
<                   anIntFaces.Append( itF.Value() );
<             }
<           }
<         }
< 
<         // ** 3. faces cut by edges of aCheckFace
<         TopExp_Explorer expE (aCheckFace, TopAbs_EDGE);
<         for ( ; expE.More(); expE.Next())
<         {
<           const TopoDS_Shape & aCheckEdge = expE.Current();
<           if (aCheckedShapes.Add( aCheckEdge ) &&
<               myInter3d.IsSectionEdge( TopoDS::Edge( aCheckEdge )))
<           {
<             itF.Initialize( myInter3d.SectionEdgeFaces( TopoDS::Edge( aCheckEdge )));
<             for (; itF.More(); itF.Next()) 
<               if (aCheckFace != itF.Value())
<                 anIntFaces.Append( itF.Value() );
<           }
<         }
< 
<         // process faces interfering with aCheckFace and shapes they
<         // belong to
<         for (itF.Initialize (anIntFaces); itF.More(); itF.Next())
<         {
<           const TopoDS_Shape & F = itF.Value();
<           if (! aCheckedShapes.Add( F ))
<             continue;
< 
<           Standard_Boolean isTool = myMapTools.Contains( F );
<           if (isTool && 
<               myFaceShapeMap( aCheckFace ).ShapeType() == TopAbs_SOLID )
<           {
<             // a tool interfering with a solid
<             if (aSectionFaces.Contains( F ))
<               AddShape( F );
<             ++ nbFoundTools;
<             if (nbFoundTools == myMapTools.Extent())
<               return;
<           }
< 
<           const TopoDS_Shape & S = myFaceShapeMap( F );
<           if (aCheckedShapes.Add( S ))
<           {
<             // a new shape interefering with aCurrentSolids is found
<             if (!isTool && S.ShapeType() == TopAbs_SOLID)
<               aCurrentSolids.Add ( S );
<             // add faces to aFacesToCheck list
<             for ( exp.Init( S, TopAbs_FACE ); exp.More(); exp.Next())
<               aFacesToCheck.Append ( exp.Current() );
<           }
<         }
<       } // loop on aFacesToCheck
< 
<       // Here aCurrentSolids contains all solids interfering with each other.
<       // aCheckedShapes contains all faces belonging to shapes included
<       // in or interfering with aCurrentSolids or previously checked solids.
<       // Test if tool faces that do not interefere with other shapes are
<       // wrapped by any of aCurrentSolids
< 
<       TopTools_MapIteratorOfMapOfShape aSolidIt (aCurrentSolids);
<       for ( ; aSolidIt.More(); aSolidIt.Next())
<       {
<         const TopoDS_Shape & aSolid = aSolidIt.Key();
<         TopTools_MapOfShape aCheckedTools( myMapTools.Extent() );
< 
<         TopTools_MapIteratorOfMapOfShape aToolIt (myMapTools);
<         for ( ; aToolIt.More(); aToolIt.Next())
<         {
<           const TopoDS_Shape & aToolFace = aToolIt.Key();
<           if (aCheckedShapes.Contains( aToolFace ) || // already found
<               aCheckedTools.Contains( aToolFace ))    // checked against aSolid
<             continue;
< 
<           const TopoDS_Shape & aToolShape = myFaceShapeMap( aToolFace );
<           TopExp_Explorer aToolFaceIt( aToolShape, TopAbs_FACE );
<           
<           Standard_Boolean isInside = IsInside( aToolShape, aSolid );
<           for ( ; aToolFaceIt.More(); aToolFaceIt.Next() )
<           {
<             const TopoDS_Shape & aTool = aToolFaceIt.Current();
<             aCheckedTools.Add( aTool );
<             if (isInside)
<             {
<               if (aSectionFaces.Contains( aTool ))
<                 AddShape( aTool );
<               ++ nbFoundTools;
<               if (nbFoundTools == myMapTools.Extent())
<                 return;
<               aCheckedShapes.Add( aTool );
<             }
<           }
<         }
<       }
<       
<     } // loop on solid shapes
<   }
< }
diff -r ../src/PARTITION/Partition_Spliter.hxx ../../../GEOM_SRC/src/PARTITION/Partition_Spliter.hxx
3c3,20
< //  Copyright (C) 2003  CEA/DEN, EDF R&D
---
> //  Copyright (C) 2003  OPEN CASCADE, EADS/CCR, LIP6, CEA/DEN,
> //  CEDRAT, EDF R&D, LEG, PRINCIPIA R&D, BUREAU VERITAS 
> // 
> //  This library is free software; you can redistribute it and/or 
> //  modify it under the terms of the GNU Lesser General Public 
> //  License as published by the Free Software Foundation; either 
> //  version 2.1 of the License. 
> // 
> //  This library is distributed in the hope that it will be useful, 
> //  but WITHOUT ANY WARRANTY; without even the implied warranty of 
> //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
> //  Lesser General Public License for more details. 
> // 
> //  You should have received a copy of the GNU Lesser General Public 
> //  License along with this library; if not, write to the Free Software 
> //  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA 
> // 
> //  See http://www.opencascade.org/SALOME/ or email : webmaster.salome@opencascade.org 
9a27
> 
104d121
< Standard_EXPORT   void MakeSolids(const TopoDS_Shape& Solid,TopTools_ListOfShape& Shells) ;
111,113d127
< Standard_EXPORT static  Standard_Boolean IsInside(const TopoDS_Shape& S1,const TopoDS_Shape& S2) ;
< Standard_EXPORT   TopoDS_Shape GetOriginalShape(const TopoDS_Shape& aShape) const;
< Standard_EXPORT   void FindToolsToReconstruct() ;
124,127d137
< TopTools_MapOfShape myEqualEdges;
< TopTools_MapOfShape myNewSection;
< TopTools_MapOfShape myClosedShapes;
< TopTools_MapOfShape myWrappingSolid;
129,130c139
< TopTools_DataMapOfShapeShape myInternalFaces;
< TopTools_DataMapOfShapeShape myIntNotClFaces;
---
> TopTools_MapOfShape myNewSection;
136a146,148
> TopTools_MapOfShape myEqualEdges;
> TopTools_DataMapOfShapeShape myInternalFaces;
> TopTools_DataMapOfShapeShape myIntNotClFaces;
Only in ../../../GEOM_SRC/src/SKETCHER: CVS
diff -r ../src/SKETCHER/GEOM_Sketcher.cxx ../../../GEOM_SRC/src/SKETCHER/GEOM_Sketcher.cxx
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/SKETCHER/GEOM_Sketcher.h ../../../GEOM_SRC/src/SKETCHER/GEOM_Sketcher.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/SKETCHER/GEOM_SketcherStatus.h ../../../GEOM_SRC/src/SKETCHER/GEOM_SketcherStatus.h
27c27
< //  $Header$
---
> //  $Header$
diff -r ../src/SKETCHER/Makefile.in ../../../GEOM_SRC/src/SKETCHER/Makefile.in
27c27
< #  $Header$
---
> #  $Header$
30c30
< top_builddir=../../..
---
> top_builddir=../..
38,39c38
< 
< LIB = libGeometrySketcher.la 
---
> LIB = libGEOMSketcher.la 
48,50c47,49
< CPPFLAGS += $(OCC_INCLUDES) $(QT_INCLUDES)
< CXXFLAGS += $(OCC_CXXFLAGS)
< LDFLAGS  += $(QT_LIBS) $(CAS_LDPATH) -lTKTopAlgo  
---
> CPPFLAGS += $(OCC_INCLUDES) $(QT_INCLUDES) -I${KERNEL_ROOT_DIR}/include/salome
> CXXFLAGS += $(OCC_CXXFLAGS) -I${KERNEL_ROOT_DIR}/include/salome
> LDFLAGS  += $(OCC_KERNEL_LIBS) $(OCC_MODELER_LIBS) -L${KERNEL_ROOT_DIR}/lib/salome
